<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>coder - Category - LoveIt</title>
        <link>https://example.com/categories/coder/</link>
        <description>coder - Category - LoveIt</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Wed, 21 Jul 2021 00:00:00 &#43;0000</lastBuildDate><atom:link href="https://example.com/categories/coder/" rel="self" type="application/rss+xml" /><item>
    <title>gin源码</title>
    <link>https://example.com/post/2021/20210721-gin/</link>
    <pubDate>Wed, 21 Jul 2021 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://example.com/post/2021/20210721-gin/</guid>
    <description><![CDATA[gin是go开发的一个开源高性能http框架，其主要是把go官方的net/http进行了扩展，前缀树实现了动态路由、支持了中间件、对请求信息进行封装方便用户层使用等。本文基于 gin v1.7.2版本
创建流程 一个Engine实例可以使用New 或者 Default进行创建，唯一区别就是Default默认增加了两个中间件：日志Logger(), panic捕获 Recovery()
初始化会初始化以下内容：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  //gin.go  engine := &amp;Engine{ //默认的分组 	RouterGroup: RouterGroup{ Handlers: nil, basePath: &#34;/&#34;, root: true, }, FuncMap: template.FuncMap{}, RedirectTrailingSlash: true, RedirectFixedPath: false, HandleMethodNotAllowed: false, ForwardedByClientIP: true, RemoteIPHeaders: []string{&#34;X-Forwarded-For&#34;, &#34;X-Real-IP&#34;}, TrustedProxies: []string{&#34;0.]]></description>
</item><item>
    <title>grpc-go</title>
    <link>https://example.com/post/2021/20210119-grpc/</link>
    <pubDate>Tue, 19 Jan 2021 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://example.com/post/2021/20210119-grpc/</guid>
    <description><![CDATA[grpc Server 本文简单阅读源代码，了解grpc server的执行流程，从建立连接，到处理一条请求的过程。
使用方式 使用方式很简单，生成pb，注册建立服务，就可以等待请求了
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  type Hello struct{ } func (h *Hello) Say(ctx context.Context, request pb.HelloRequest)(*pb.HelloResponse, error){ fmt.Println(request.Msg) return &amp;pb.HelloResponse{Msg: &#34;wwww&#34;}, nil } func main(){ lis, _ := net.Listen(&#34;tcp&#34;, &#34;127.0.0.1:8888&#34;) //1. 创建一个grpc服务器对象  gRpcServer := grpc.NewServer() //2. 注册pb函数  pb.RegisterHelloServiceServer(gRpcServer, &amp;Hello{}) //3. 开启服务端  //阻塞  gRpcServer.Serve(lis) }   建立grpc server流程 NewServer NewServer进行创建一个grpc服务，初始化一些参数。还可以进行函数选项模式，来传递初始化的配置。 默认情况下会建立一个以下参数的grpc服务：]]></description>
</item><item>
    <title>计算机网络-传输层</title>
    <link>https://example.com/post/2021/20210105-tcpudp/</link>
    <pubDate>Tue, 05 Jan 2021 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://example.com/post/2021/20210105-tcpudp/</guid>
    <description><![CDATA[TCP/IP 模型 应用层将数据传递给传输层，传输层将数据分段，每段加入自己的首部数据，然后传递给下一层，之后的每层都会封装上自己层需要的首部，最后经过物理链路传递到指定主机，然后每层又向剥洋葱一样，一层层处理自己的首部数据，到达传输层，传输层最终交付给应用程序。 数据传输流程： 传输层 与应用层的关系：应用层将数据发送给传输层，传输层将其进行分段处理，每段数据加入头协议，然后将每组发出去 与网络层的关系：分组的数据发给网络层，网络层将数据真正的发给链路层，然后从物理链路发到指定服务的进程中去
举例： 北京一个家庭： 小明家庭 天津一个家庭： 小红家庭 小明写了封信，交给管家，管家将信给邮政局，邮政局收到后，寄到天津小红家，管家将信给小红；
小明家庭的任意成员写信-&gt;小明家的管家-&gt;邮局-&gt;小红家的管家-&gt;小红
应用层数据：小明信的内容 进程：小明，小明家庭成员都是这个主机内所有进程。 主机：小明的家庭 和 小红的家庭 传输层：管家，每个主机有一个管家 网络层：邮局
简单介绍udp tcp tcp将应用层数据，分段处理 称为 报文段（seg-ment)；upd将应用层数据，分段处理 称为 数据报。 IP层 网际协议，为主机之间提供逻辑通信，尽力而为的交付服务（best-effort delivery service) 所以不保证数据不会丢失，报文段的顺序，并且附带了一个唯一表示的地址也就是ip地址来进行主机之间的确认。 udp和tcp 的基本责任是对两个端系统间的进程进行交付服务。主机间交付扩展到进程间交付被称之为 传输层的多路复用和多路分解。 并且都提供了差错检查字段，来对完整性进行校验。而udp也是不可靠服务，所以它仅提供了这两种服务：差错校验和进程到进程之间的交付。 tcp提供了可靠传输，通过流量控制，序号，确认，定时器等确保数据正确的，有序的到达接收进程;还提供了拥塞控制，调节网络流量速率，为整个互联网代理通用的好处，提供平等的带宽，这也是udp的传输速率高于tcp原因之一。
对于拥塞控制可以举个例子：拥塞控制如同交通规则，当车辆很多的情况下，大家都遵守交通虽然会降低一点开车速度。但对整个城市的交通提供了高效的运转，一辆辆tcp汽车，会公平的遵守交通达到目的地。而一辆udp汽车运行其中不遵守交规，在车辆少的情况下，是绝对高速的，但高峰期的时候绝对会出现各种事故（丢包率提高等）
多路复用，多路分解 多路复用:一个主机有多个进程，每个进程为了通信会建立一个套接字（socket)，而一个主机只有一个传输层，所以多个socket将数据传输给传输层，传输层将这些数据进行封装上首部信息（为了以后的分解）从而生成报文段。然后将报文段传递给网络层，这个过程就是多路复用。
多路分解:当主机收到其他主机的数据，传输层根据报文段的首部信息找到指定的socket。这个过程就是多路分解
举例：依旧是上面的例子，当管家收到信件后，需要依靠信件上的名字，给指定的成员（小明，爸爸，妈妈）。 这个管家的操作就是多路分解。当成员（小明，爸爸，妈妈）写了信给管家，管家进行整理然后发送给邮政局，这个管家的操作就是多路复用
通过上述描述，传输层的多路复用的要求是：
 每一个套接字要有唯一的标识，否则传输层无法分辨该将数据给谁 每个报文段要有特殊的字段来标识，要交付给哪个套接字（也就是端口 port）  1 2 3 4 5 6 7  |-----------------| | 源端口 | 目的端口 | |-----------------| | 其他首部字段 | |-----------------| | 应用数据 | |-----------------|   udp的多路复用的多路复用/分解 一个udp套接字使用一个二元组来全面标识，该二元组包含：一个目的IP地址和一个目的端口号。这也是为什么多个客户端连会接到同一个服务进程的同一个套接字]]></description>
</item><item>
    <title>MIT6.828 - 02-Lab1.Util</title>
    <link>https://example.com/post/2020/20200407-mit6.828-02-lab1/</link>
    <pubDate>Tue, 07 Apr 2020 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://example.com/post/2020/20200407-mit6.828-02-lab1/</guid>
    <description><![CDATA[实验说明 每一个Lab对应一个git 分支，本实验分支为 util，主要是实现5个命令程序。在 xv6-riscv-fall19项目里， kernel是内核， user是用户态程序， 代码写到user里，然后再Makefile UPROGS变量中加入的相应名称即可：
1 2 3 4 5 6  UPROGS=\ 	$U/_sleep\ 	$U/_pingpong\ 	$U/_primes\ 	$U/_find\ 	$U/_xargs\   我的实验代码都在 自己fork的仓库里
执行make grade会测试自己写的api，如果执行失败可能是未安装python(apt-get install python)，就像下面一样：
1 2 3 4 5 6 7 8  $ make qemu-gdb OK (5.1s) sleep, returns: $ make qemu-gdb OK (1.1s) sleep, makes syscall: $ make qemu-gdb OK (0.7s)   执行 make 然后 make qemu 编译运行操作系统]]></description>
</item><item>
    <title>MIT6.828 - 01.环境搭建</title>
    <link>https://example.com/post/2020/20200406-mit6.828-01/</link>
    <pubDate>Mon, 06 Apr 2020 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://example.com/post/2020/20200406-mit6.828-01/</guid>
    <description><![CDATA[概述 6.S081 目标  理解操作系统设计与实现 掌握扩展迷你操作系统的实践经验 掌握编写系统软件的经验  环境搭建 我使用docker进行环境搭建，构建自己的image，方便部署，之后换电脑也无需重复安装各种工具。 我的image: docker pull zuojxin/xv6 (image太大了，应该是可以优化的)
docker 简单命令  创建自己的docker：docker build -t orige_name/image_name:tag 安装镜像：docker pull image_name 删除镜像：docker rmi image_name 删除容器：docker rm container_name 查看已安装镜像：docker images 启动镜像容器： docker run -t -i image_name:tag 保存容器：docker commit container_id image_name 上传镜像：docker push image_name:tag 本地文件拷贝到docker容器：docker cp 文件 container_id:容器内路径 精简image大小：http://www.dockerinfo.net/3328.html 清理docker缓存：https://blog.fundebug.com/2018/01/10/how-to-clean-docker-disk/  Dockerfile 1 2 3 4 5 6 7  FROMdebianLABEL xv6 &lt;zuojxin@docker.com&gt;RUN apt-get update RUN apt-get -y install git build-essential gdb-multiarch qemu-system-misc \  gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu  RUN git clone https://github.]]></description>
</item><item>
    <title>MIT6.828 - 00.开始</title>
    <link>https://example.com/post/2020/20200405-mit6.828-00/</link>
    <pubDate>Sun, 05 Apr 2020 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://example.com/post/2020/20200405-mit6.828-00/</guid>
    <description><![CDATA[前言 写一个操作系统一直是我的梦想，MIT 6.828-2019fall是最好的课程之一。我将记录学习的过程与实践， 所有代码都会上传至我的github
目录 LEC 1: 环境搭建 &amp; Lab1:Util
主要学习的资料 官方讲义
xv6 文档
xv6源码
vx6源码分析
其他参考：
https://blog.mky.moe/
https://blog.csdn.net/bysui/category_6232831.html
https://www.cnblogs.com/fatsheep9146/category/769143.html
  ]]></description>
</item><item>
    <title>源码阅读 - go Context</title>
    <link>https://example.com/post/2020/20200401-go-context/</link>
    <pubDate>Wed, 01 Apr 2020 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://example.com/post/2020/20200401-go-context/</guid>
    <description><![CDATA[Context有什么用 当处理一个请求A，而这个请求需要在3秒内完成相应，A请求分别创建了B和C goroutine来处理逻辑，如果B或者C处理时间过长超过了3秒，那么继续执行显然是没必要且浪费资源。这时候就需要一个能终止他们的操作，而go没有提供类似 goroutineID这样的变量来记录goroutine状态。官方认为这样非常容易被滥用。所以Context就为此而来。
 利用 channel/select ，以信号的方式来通知需要停止的goroutine 可以为Context记录一个key/value 来包含一些请求相关的信息  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  func B(ctx context.Context) error { for { select { case &lt;-time.After(1 * time.Second): fmt.Println(&#34;hello B&#34;) case &lt;-ctx.Done(): fmt.Println(&#34;b is end&#34;) return ctx.]]></description>
</item><item>
    <title>读CSAPP(4) - 虚拟内存</title>
    <link>https://example.com/post/2019/20190928-csapp4/</link>
    <pubDate>Sat, 28 Sep 2019 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://example.com/post/2019/20190928-csapp4/</guid>
    <description><![CDATA[虚拟内存系统解决了物理寻址的缺点。利用内存管理单元（MMU）和页表（Page Table）将虚拟地址转换为物理内存地址。 进程运行过程不再加载全部数据，而是只保留当前运行需要的数据在内存中。为了让MMU更高效加入了TLB，缓存映射关系，还利用多级页表降低页表内存占用有了
虚拟内存系统 计算机系统主存被组织成一个连续字节大小的数组，每一个数组成员都有一个唯一的物理地址（Physical Address） 早期计算机使用物理寻址方式，这样的坏处是
 系统中多个进程所使用的内存，进程之间容易互相读写数据造成各种问题 每个进程内存分布不同，管理不便 进程中暂无用处的数据也会被加载，进程过多就会导致内存不够用  现代处理器使用虚拟寻址（Virtual Address），利用虚拟地址映射成物理地址再进行访问，解决了上面的主要问题。既然需要地址转换，这就需要内存管理单元（Memory Management Unit，MMU）和页表（Page Table，PT）来处理
 因为每个进程都有统一的访问方式，这样进程之间也不会互相影响 内存管理更加简单，每个进程看起来都在独享全部内存 节省内存空间，利用内存分页，物理内存中只保留进程当前活动区域，并根据需要在磁盘和主存之间来回传送数据  页表 虚拟内存系统将虚拟内存分割成一个个大小相同的虚拟页（Virtual Page，VP），类似的物理内存也被分割成物理页（Physical Page，PP）大小和VP相同，物理页也被称为叶帧（Page Frame）。 页表其实就是一个数组，每个元素称为页表项（Page Table Entry，PTE），PTE负责把虚拟页映射到磁盘或者物理页上。
任意时刻虚拟页面的集合都分为三个不想交的子集：
 未分配的：VM系统还未分配的页，物理内存，磁盘都没有与之关联的数据（图中0，3） 已分配已缓存的：已分配到了物理内存中（图中1，4，6） 已分配未缓存：数据块存在于磁盘中，还未被加载到内存（图中2，5，7）  页表项 当MMU从PTE获取物理内存地址，要根据PTE知道：
 虚拟页是否被缓存了 缓存命中需要知道具体存在于哪个物理内存页中 缓存未命中需要知道此虚拟页在磁盘的什么地方进行缓存替换操作  整个页表数据结构由操作系统进行负责维护，以及在磁盘与主存之间来回传送页，进行替换的时候需要向系统内核发送一个缺页异常，内核会做一些处理。 PTE负责把虚拟页映射到磁盘或者物理页上，假设需要两个数据：
 地址字段：存放映射的地址 有效位：判断此页是否被缓存  有了这两个字段就可以进行判断：
 设置了有效位，地址字段不为空：数据缓存在物理内存页中，地址字段为物理页的起始位置 没有设置有效位，地址字段为空：此虚拟页还未被分配 没有设置有效位，地址字段不为空：虚拟页被分配，但还未缓存到物理内存中，只在磁盘上，地址字段指向该虚拟页在磁盘上的起始位置  映射流程 虚拟地址有两部分VPN+VPO。MMU利用VPN找到对应的PTE， 例如 VPN 0 对应 PTE 0，找到PTE后，PTE中的有效位决定是否有效，是否需要缺页处理。 如果有效，则得到其中的PPN，使用PPN+VPO 得到最终的物理内存地址
页面命中，cpu硬件流程：
缺页流程，页面命中完全由硬件处理，处理缺页需要硬件和操作系统内核协作完成：
虚拟内存系统带来的优势 权限控制 每个PTE（页表项）高位部分存储了表示权限的位，MMU通过检查这些位来进行权限控制（sup表示进程是否必须运行在内核（超级管理员）模式下才能运行）。 如果违反了权限cpu会触发一个 一般保护故障，将控制传给内核的异常处理程序，linux shell一般称之为段错误（segmentation fault） 节省内存 MMU根据虚拟地址读取页表，发现设置了有效位，表明缓存命中，地址字段存储了物理页地址，就可以找到数据在物理内存中的位置，这是页命中，相对的就会触发缺页异常（缓存不命中 page fault）： （见上图）]]></description>
</item><item>
    <title>读CSAPP(3) - 存储器层次结构</title>
    <link>https://example.com/post/2019/20190923-csapp3/</link>
    <pubDate>Mon, 23 Sep 2019 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://example.com/post/2019/20190923-csapp3/</guid>
    <description><![CDATA[了解硬件 随机访问存储器（Random-Access Memory，RAM） RAM分两类，静态（SRAM）的和动态的（DRAM），SRAM要比DRAM更快，价格也更高。 SRAM用于高速缓存存储器，可以在cpu芯片上，也可以在片下。DRAM用来作为主存以及 图形系统的帧缓冲区。无论哪种RAM一旦断电，所有信息都会丢失。
磁盘存储 磁盘存储数据的数量级更大，比RAM大得多，但读取信息要比DRAM慢10w倍，比SRAM慢100w倍。 磁盘分为机械硬盘和固态硬盘，机械硬盘的读写速度要低于固态硬盘，但价格低廉。
总线 IO总线：例如，鼠标键盘，图形卡，磁盘等设备连接的称为io总线 cpu使用内存映射I/O技术（memory-mapped I/O）来向I/O设备发起命令
 使用内存映射技术向io设备发起命令 磁盘控制器接收到命令，读取扇区，并执行到主存的DMA传送，磁盘进行直接内存访问的操作叫做DMA（Direct Memory Access） DMA传送完毕，磁盘控制器用中断方式通知cpu cpu接收到中断信号，从内存读取缓存的数据  局部性 一个好的程序应该有良好的局部性，这样可以使得效率更快
 时间局部性：被引用过一次的内存，很可能在不久的将来再次被引用多次 空间局部性：如果一个内存位置被引用了一次，那么程序再不久的将来可能会引用其附近的内存位置  看一个例子
1 2 3 4 5 6 7 8  int sumvec(int v[N]) { int i , sum = 0; for(i = 0; i &lt; N; i ++) sum+=v[i]; return sum; }   这个函数中，sum就有很好的时间局部性，在多次循环中，会一直访问同一个内存位置，因为是标量所以没有空间局部性。 数组v被顺序读取，读取第i个位置，那么附近的位置也会在下次循环中读取，所以有很好的空间局部性，但每个变量只访问一次，所以时间局部性很差。 这个函数中要么有好的时间局部性，要么有好的空间局部性，所以sumvec函数有良好的局部性。
再看一个例子：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  int sumarray1(int a[M][N]) { int i ,j , sum = 0; for(i = 0;i &lt; M ;i ++) for(j = 0; j &lt; N ;j ++) sum+=a[i][j]; return sum; } int sumarray2(int a[M][N]) { int i ,j , sum = 0; for(i = 0;i &lt; N;i ++) for(j = 0; j &lt; M ;j ++) sum+=a[i][j]; return sum; }   两个程序做的事情一模一样，效率看起来也是一样的。但根据局部性原理： sumarray1有空间局部性，sumarry2则没有。 这个二维数组存储在内存的顺序是一行行的存储，也就是按照行来读就会按序读取，按列读取就会跳着读。 空间局部性的临近读取，导致最终sumarry1更高效。]]></description>
</item><item>
    <title>Go Channel</title>
    <link>https://example.com/post/2019/20190917-go-channel/</link>
    <pubDate>Tue, 17 Sep 2019 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://example.com/post/2019/20190917-go-channel/</guid>
    <description><![CDATA[如何使用  channel在&lt;-左边 表示向channel发送数据 channel在&lt;-右边 表示从channel接收数据 close(channelName) 关闭一个channel  1 2 3 4 5 6 7 8  channel := make(chan string, 2) //发送数据: 写 channel &lt;- &#34;struct&#34; //接收数据: 读 data := &lt;-channel fmt.Println(data) close(channel)   Channel的关闭  关闭一个未初始化(nil) 的 channel 会产生 panic 重复关闭同一个 channel 会产生 panic 向一个已关闭的 channel 中发送消息会产生 panic 从一个已关闭的 channel 中读取消息永远不会阻塞，并且会返回一个为 false 状态，可以用它来判断 channel 是否关闭,close操作是对写入的关闭,但仍然可以读取,若消息均已读出，则会读到类型的初始值  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  func SendMessage(channel chan string) { go func(channel chan string) { channel &lt;- &#34;hello&#34; close(channel) fmt.]]></description>
</item></channel>
</rss>
