<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Liste - "><title>grpc-go | Liste</title><meta name=description content="Minimalistic Hugo blogging theme"><meta property="og:title" content="grpc-go"><meta property="og:description" content="grpc Server # 本文简单阅读源代码，了解grpc server的执行流程，从建立连接，到处理一条请求的过程。
使用方式 # 使用方式很简单，生成pb，注册建立服务，就可以等待请求了
type Hello struct{ } func (h *Hello) Say(ctx context.Context, request pb.HelloRequest)(*pb.HelloResponse, error){ fmt.Println(request.Msg) return &pb.HelloResponse{Msg: &#34;wwww&#34;}, nil } func main(){ lis, _ := net.Listen(&#34;tcp&#34;, &#34;127.0.0.1:8888&#34;) //1. 创建一个grpc服务器对象 gRpcServer := grpc.NewServer() //2. 注册pb函数 pb.RegisterHelloServiceServer(gRpcServer, &Hello{}) //3. 开启服务端 //阻塞 gRpcServer.Serve(lis) } 建立grpc server流程 # NewServer # NewServer进行创建一个grpc服务，初始化一些参数。还可以进行函数选项模式，来传递初始化的配置。 默认情况下会建立一个以下参数的grpc服务：
接受数据最大4M 发送数据最大2g 连接超时120秒 读和写缓存1mb 默认一个请求一个goroutine numServerWorkers # numServerWorkers设定了开启多少个工作协程，如果没设置，则来了一条消息就会处理创建一个goroutine。 如果设置了，会将请求消息进行分发给这多个worker
func (s *Server) serveStreams(st transport.ServerTransport) { st.HandleStreams(func(stream *transport."><meta property="og:type" content="article"><meta property="og:url" content="/2021/01/19/20210119-grpc/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-01-19T00:00:00+00:00"><meta property="article:modified_time" content="2021-01-19T00:00:00+00:00"><meta itemprop=name content="grpc-go"><meta itemprop=description content="grpc Server # 本文简单阅读源代码，了解grpc server的执行流程，从建立连接，到处理一条请求的过程。
使用方式 # 使用方式很简单，生成pb，注册建立服务，就可以等待请求了
type Hello struct{ } func (h *Hello) Say(ctx context.Context, request pb.HelloRequest)(*pb.HelloResponse, error){ fmt.Println(request.Msg) return &pb.HelloResponse{Msg: &#34;wwww&#34;}, nil } func main(){ lis, _ := net.Listen(&#34;tcp&#34;, &#34;127.0.0.1:8888&#34;) //1. 创建一个grpc服务器对象 gRpcServer := grpc.NewServer() //2. 注册pb函数 pb.RegisterHelloServiceServer(gRpcServer, &Hello{}) //3. 开启服务端 //阻塞 gRpcServer.Serve(lis) } 建立grpc server流程 # NewServer # NewServer进行创建一个grpc服务，初始化一些参数。还可以进行函数选项模式，来传递初始化的配置。 默认情况下会建立一个以下参数的grpc服务：
接受数据最大4M 发送数据最大2g 连接超时120秒 读和写缓存1mb 默认一个请求一个goroutine numServerWorkers # numServerWorkers设定了开启多少个工作协程，如果没设置，则来了一条消息就会处理创建一个goroutine。 如果设置了，会将请求消息进行分发给这多个worker
func (s *Server) serveStreams(st transport.ServerTransport) { st.HandleStreams(func(stream *transport."><meta itemprop=datePublished content="2021-01-19T00:00:00+00:00"><meta itemprop=dateModified content="2021-01-19T00:00:00+00:00"><meta itemprop=wordCount content="1153"><meta itemprop=keywords content="grpc,源码,"><meta name=twitter:card content="summary"><meta name=twitter:title content="grpc-go"><meta name=twitter:description content="grpc Server # 本文简单阅读源代码，了解grpc server的执行流程，从建立连接，到处理一条请求的过程。
使用方式 # 使用方式很简单，生成pb，注册建立服务，就可以等待请求了
type Hello struct{ } func (h *Hello) Say(ctx context.Context, request pb.HelloRequest)(*pb.HelloResponse, error){ fmt.Println(request.Msg) return &pb.HelloResponse{Msg: &#34;wwww&#34;}, nil } func main(){ lis, _ := net.Listen(&#34;tcp&#34;, &#34;127.0.0.1:8888&#34;) //1. 创建一个grpc服务器对象 gRpcServer := grpc.NewServer() //2. 注册pb函数 pb.RegisterHelloServiceServer(gRpcServer, &Hello{}) //3. 开启服务端 //阻塞 gRpcServer.Serve(lis) } 建立grpc server流程 # NewServer # NewServer进行创建一个grpc服务，初始化一些参数。还可以进行函数选项模式，来传递初始化的配置。 默认情况下会建立一个以下参数的grpc服务：
接受数据最大4M 发送数据最大2g 连接超时120秒 读和写缓存1mb 默认一个请求一个goroutine numServerWorkers # numServerWorkers设定了开启多少个工作协程，如果没设置，则来了一条消息就会处理创建一个goroutine。 如果设置了，会将请求消息进行分发给这多个worker
func (s *Server) serveStreams(st transport.ServerTransport) { st.HandleStreams(func(stream *transport."><link rel=canonical href=/2021/01/19/20210119-grpc/><meta name=monetization content="$twitter.xrptipbot.com/ronaldsvilcins"><link rel=dns-prefetch href=https://www.google-analytics.com><link href=https://www.google-analytics.com rel=preconnect crossorigin><link rel=alternate type=application/atom+xml title=Liste href=atom.xml><link rel=alternate type=application/json title=Liste href=feed.json><link rel="shortcut icon" type=image/png href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNk+A8AAQUBAScY42YAAAAASUVORK5CYII="><style>*,:after,:before{box-sizing:border-box;padding:0}body{font:1rem/1.5 '-apple-system',BlinkMacSystemFont,avenir next,avenir,helvetica,helvetica neue,ubuntu,roboto,noto,segoe ui,arial,sans-serif;text-rendering:optimizeLegibility;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;padding:2rem;color:#000}.skip-link{position:absolute;top:-40px;left:0;background:#eee;z-index:100}.skip-link:focus{top:0}h1,h2,h3,h4,h5,strong,b{font-size:inherit;font-weight:600}header{line-height:2;padding-bottom:1.5rem}.link{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-decoration:none}.time{font-variant-numeric:tabular-nums;white-space:nowrap}blockquote{border-left:5px solid #eee;padding-left:1rem;margin:0}a,a:visited{color:inherit}a:hover,a.heading-link{text-decoration:none}pre{padding:.5rem;overflow:auto;overflow-x:scroll;overflow-wrap:normal}code,pre{font-family:San Francisco Mono,Monaco,consolas,lucida console,dejavu sans mono,bitstream vera sans mono,monospace;font-size:normal;font-size:small;background:#eee}code{padding:.1rem;border:none}ul{list-style-type:square}ul,ol{padding-left:1.2rem}.list{line-height:2;list-style-type:none;padding-left:0}.list li{padding-bottom:.1rem}.meta{color:#777}.content{max-width:70ch;margin:0 auto}header{line-height:2;display:flex;justify-content:space-between;padding-bottom:1rem}header a{text-decoration:none}header ul{list-style-type:none;padding:0}header li,header a{display:inline}h2.post{padding-top:.5rem}header ul a:first-child{padding-left:1rem}.nav{height:1px;background:#000;content:'';max-width:10%}.list li{display:flex;align-items:baseline}.list li time{flex:initial}.hr-list{margin-top:0;margin-bottom:0;margin-right:.5rem;margin-left:.5rem;height:1px;border:0;border-bottom:1px dotted #ccc;flex:1 0 1rem}.m,hr{border:0;margin:3rem 0}img{max-width:100%;height:auto}</style><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","articleSection":"posts","name":"grpc-go","headline":"grpc-go","alternativeHeadline":"","description":"grpc Server # 本文简单阅读源代码，了解grpc server的执行流程，从建立连接，到处理一条请求的过程。\n使用方式 # 使用方式很简单，生成pb，注册建立服务，就可以等待请求了\ntype Hello struct{ } func (h *Hello) Say(ctx context.Context, request pb.HelloRequest)(*pb.HelloResponse, error){ fmt.Println(request.Msg) return \u0026amp;pb.HelloResponse{Msg: \u0026quot;wwww\u0026quot;}, nil } func main(){ lis, _ := net.Listen(\u0026quot;tcp\u0026quot;, \u0026quot;127.0.0.1:8888\u0026quot;) \/\/1. 创建一个grpc服务器对象 gRpcServer := grpc.NewServer() \/\/2. 注册pb函数 pb.RegisterHelloServiceServer(gRpcServer, \u0026amp;Hello{}) \/\/3. 开启服务端 \/\/阻塞 gRpcServer.Serve(lis) } 建立grpc server流程 # NewServer # NewServer进行创建一个grpc服务，初始化一些参数。还可以进行函数选项模式，来传递初始化的配置。 默认情况下会建立一个以下参数的grpc服务：\n接受数据最大4M 发送数据最大2g 连接超时120秒 读和写缓存1mb 默认一个请求一个goroutine numServerWorkers # numServerWorkers设定了开启多少个工作协程，如果没设置，则来了一条消息就会处理创建一个goroutine。 如果设置了，会将请求消息进行分发给这多个worker\nfunc (s *Server) serveStreams(st transport.ServerTransport) { st.HandleStreams(func(stream *transport.","inLanguage":"en-us","isFamilyFriendly":"true","mainEntityOfPage":{"@type":"WebPage","@id":"\/2021\/01\/19\/20210119-grpc\/"},"author":{"@type":"Person","name":"Liste"},"creator":{"@type":"Person","name":"Liste"},"accountablePerson":{"@type":"Person","name":"Liste"},"copyrightHolder":"Liste","copyrightYear":"2021","dateCreated":"2021-01-19T00:00:00.00Z","datePublished":"2021-01-19T00:00:00.00Z","dateModified":"2021-01-19T00:00:00.00Z","publisher":{"@type":"Organization","name":"Liste","url":"","logo":{"@type":"ImageObject","url":"","width":"32","height":"32"}},"image":"","url":"\/2021\/01\/19\/20210119-grpc\/","wordCount":"1153","genre":["grpc","源码"],"keywords":["grpc","源码"]}</script></head><body><a class=skip-link href=#main>Skip to main</a><main id=main><div class=content><header><p style=padding:0;margin:0><a href=/><b>Listed</b></a></p><ul style=padding:0;margin:0><li><a href=/projects>Projects</a></li><li><a href=/about>About</a></li></ul></header><hr class=hr-list style=padding:0;margin:0><h2 class=post>grpc-go</h2><h1 id=grpc-server>grpc Server <a href=#grpc-server class="hash g">#</a></h1><p>本文简单阅读源代码，了解grpc server的执行流程，从建立连接，到处理一条请求的过程。</p><h2 id=使用方式>使用方式 <a href=#%e4%bd%bf%e7%94%a8%e6%96%b9%e5%bc%8f class="hash g">#</a></h2><p>使用方式很简单，生成pb，注册建立服务，就可以等待请求了</p><pre><code class=language-go>type Hello struct{
}

func (h *Hello) Say(ctx context.Context, request pb.HelloRequest)(*pb.HelloResponse, error){
    fmt.Println(request.Msg)
    return &amp;pb.HelloResponse{Msg: &quot;wwww&quot;}, nil
}

func main(){
    lis, _ := net.Listen(&quot;tcp&quot;, &quot;127.0.0.1:8888&quot;)
    //1. 创建一个grpc服务器对象
    gRpcServer := grpc.NewServer()
    //2. 注册pb函数
    pb.RegisterHelloServiceServer(gRpcServer, &amp;Hello{})
    //3. 开启服务端
    //阻塞
    gRpcServer.Serve(lis)
}
</code></pre><h2 id=建立grpc-server流程>建立grpc server流程 <a href=#%e5%bb%ba%e7%ab%8bgrpc-server%e6%b5%81%e7%a8%8b class="hash g">#</a></h2><h3 id=newserver>NewServer <a href=#newserver class="hash g">#</a></h3><p>NewServer进行创建一个grpc服务，初始化一些参数。还可以进行<code>函数选项模式</code>，来传递初始化的配置。
默认情况下会建立一个以下参数的grpc服务：</p><ol><li>接受数据最大4M</li><li>发送数据最大2g</li><li>连接超时120秒</li><li>读和写缓存1mb</li><li>默认一个请求一个goroutine</li></ol><h4 id=numserverworkers>numServerWorkers <a href=#numserverworkers class="hash g">#</a></h4><p>numServerWorkers设定了开启多少个工作协程，如果没设置，则来了一条消息就会处理创建一个goroutine。
如果设置了，会将<code>请求消息</code>进行分发给这多个worker</p><pre><code class=language-go>func (s *Server) serveStreams(st transport.ServerTransport) {
	st.HandleStreams(func(stream *transport.Stream) {
		if s.opts.numServerWorkers &gt; 0 {
			data := &amp;serverWorkerData{st: st, wg: &amp;wg, stream: stream}
			select {
			case s.serverWorkerChannels[atomic.AddUint32(&amp;roundRobinCounter, 1)%s.opts.numServerWorkers] &lt;- data:
			default:
				go func() {
					s.handleStream(st, stream, s.traceInfo(st, stream))
					wg.Done()
				}()
			}
		} else {
			go func() {
				defer wg.Done()
				s.handleStream(st, stream, s.traceInfo(st, stream))
			}()
		}
	})
}
</code></pre><h3 id=注册函数>注册函数 <a href=#%e6%b3%a8%e5%86%8c%e5%87%bd%e6%95%b0 class="hash g">#</a></h3><p>利用反射，将具体实现的结构体和与之对应的函数存储到 grpcServer的<code>services</code>变量中</p><ul><li>key: 结构体名称 （一般在pb文件里会根据proto生成）</li><li>value: 函数信息（调用函数的指针，函数名称，Metadata）</li></ul><p>将函数信息存储后，来了一个请求根据请求信息，找到指定的函数，进行调用</p><pre><code class=language-go>type ServiceDesc struct {
	ServiceName string //服务名称
	HandlerType interface{} //结构体类型
	Methods     []MethodDesc//一元函数
	Streams     []StreamDesc//流函数
	Metadata    interface{}// 元数据
}

//注册服务函数
//args: sd 文件描述, srv: 具体实现的结构体
func (s *Server) RegisterService(sd *ServiceDesc, ss interface{}) {
	if ss != nil {
		ht := reflect.TypeOf(sd.HandlerType).Elem()
		st := reflect.TypeOf(ss)
		if !st.Implements(ht) {
			logger.Fatalf(&quot;grpc: Server.RegisterService found the handler of type %v that does not satisfy %v&quot;, st, ht)
		}
	}
	s.register(sd, ss)
}

//利用反射将服务注册到字典
func (s *Server) register(sd *ServiceDesc, ss interface{}) {
	s.mu.Lock()
	defer s.mu.Unlock()
	s.printf(&quot;RegisterService(%q)&quot;, sd.ServiceName)
	if s.serve {
		logger.Fatalf(&quot;grpc: Server.RegisterService after Server.Serve for %q&quot;, sd.ServiceName)
	}
	if _, ok := s.services[sd.ServiceName]; ok {
		logger.Fatalf(&quot;grpc: Server.RegisterService found duplicate service registration for %q&quot;, sd.ServiceName)
	}
	info := &amp;serviceInfo{
		serviceImpl: ss,
		methods:     make(map[string]*MethodDesc),
		streams:     make(map[string]*StreamDesc),
		mdata:       sd.Metadata,
	}
	for i := range sd.Methods {
		d := &amp;sd.Methods[i]
		info.methods[d.MethodName] = d
	}
	for i := range sd.Streams {
		d := &amp;sd.Streams[i]
		info.streams[d.StreamName] = d
	}
	s.services[sd.ServiceName] = info
}
</code></pre><h3 id=监听>监听 <a href=#%e7%9b%91%e5%90%ac class="hash g">#</a></h3><p>当客户端建立连接，会为其单独创建一个goroutine进行后续的数据传输</p><pre><code class=language-go>func Serve(lis net.Listener) error{
    //...
	for {
		rawConn, err := lis.Accept()
		go func() {
			s.handleRawConn(rawConn)
		}()
    }
    //...
}
</code></pre><h2 id=处理一个grpc请求的流程>处理一个grpc请求的流程 <a href=#%e5%a4%84%e7%90%86%e4%b8%80%e4%b8%aagrpc%e8%af%b7%e6%b1%82%e7%9a%84%e6%b5%81%e7%a8%8b class="hash g">#</a></h2><ol><li>建立连接</li><li>创建goroutine处理连接</li><li>grpc基于http2，根据tcp连接信息 创建http2 传输结构 newHTTP2Transport</li><li>创建新的goroutine，将http2传输信息 进行处理</li><li>经过http2_server.go:455中的处理，从tcp层读取数据进行解析，最后执行此处传递过去的函数指针</li><li>根据请求信息，找到指定函数。最后进行调用注册的应用层业务<ol><li>找到字典里对应的执行函数</li><li>如果没找到，则判断unknownStreamDesc 执行，这个一般用来自定义路由</li><li>判断一元，还是流</li><li>执行函数</li><li>将结果写回给对方</li></ol></li><li>移除连接</li></ol><h3 id=code>code <a href=#code class="hash g">#</a></h3><pre><code class=language-go>func Serve(lis net.Listener) error{
	for {
        //1. 建立连接
		rawConn, err := lis.Accept()
		go func() {
            //2. 创建goroutine处理连接
			s.handleRawConn(rawConn)
		}()
    }
}

func (s *Server) handleRawConn(rawConn net.Conn) {
	conn, authInfo, err := s.useTransportAuthenticator(rawConn)
	// 3. grpc基于http2，根据tcp连接信息 创建http2 传输结构
	st := s.newHTTP2Transport(conn, authInfo)
	go func() {
        //4. 创建新的goroutine，将http2传输信息 进行处理
        s.serveStreams(st)
        //7. 移除连接
		s.removeConn(st)
	}()
}

func (s *Server) serveStreams(st transport.ServerTransport) {
    //5. 经过http2_server.go:455中的处理，从tcp层读取数据进行解析，最后执行此处传递过去的函数指针
	st.HandleStreams(func(stream *transport.Stream) {
		if s.opts.numServerWorkers &gt; 0 {
			data := &amp;serverWorkerData{st: st, wg: &amp;wg, stream: stream}
			select {
			case s.serverWorkerChannels[atomic.AddUint32(&amp;roundRobinCounter, 1)%s.opts.numServerWorkers] &lt;- data:
			default:
				go func() {
					s.handleStream(st, stream, s.traceInfo(st, stream))
					wg.Done()
				}()
			}
		} else {
			go func() {
				defer wg.Done()
				s.handleStream(st, stream, s.traceInfo(st, stream))
			}()
		}
	})
}

func (s *Server) handleStream(t transport.ServerTransport, stream *transport.Stream, trInfo *traceInfo) {
    //6. 根据请求信息，找到指定函数。最后进行调用注册的应用层业务
	srv, knownService := s.services[service]
	if knownService {
		if md, ok := srv.methods[method]; ok {
			s.processUnaryRPC(t, stream, srv, md, trInfo)
			return
		}
		if sd, ok := srv.streams[method]; ok {
			s.processStreamingRPC(t, stream, srv, sd, trInfo)
			return
		}
	}
	// 此处可以进行自定义的路由
	if unknownDesc := s.opts.unknownStreamDesc; unknownDesc != nil {
		s.processStreamingRPC(t, stream, nil, unknownDesc, trInfo)
		return
    }
    ...
}
</code></pre><h2 id=解析请求头数据的细节>解析请求头数据的细节 <a href=#%e8%a7%a3%e6%9e%90%e8%af%b7%e6%b1%82%e5%a4%b4%e6%95%b0%e6%8d%ae%e7%9a%84%e7%bb%86%e8%8a%82 class="hash g">#</a></h2><ol><li>读取底层tcp数据，最后进行解析</li><li>解析头数据</li><li>根据解析后的头数据，进行一系列的设置<ol><li>设置：超时的ctx</li><li>设置：metadata 存入context中</li></ol></li><li>执行函数指针</li></ol><p>http2从tcp将数据报转换成http2认识的具体数据。之后grpc将http2的数据封装成grpc用到的stream结构中，还有一些参数<code>timeout</code>、<code>content-type</code>等封装到stream中的ctx中，到这里为止还没有对具体的请求数据做任何操作。</p><pre><code class=language-go>type decodeState struct {
	serverSide bool //用了http2的解析，就一定是true
	data parsedHeaderData//请求过来的关键参数
}

func (t *http2Server) HandleStreams(handle func(*Stream), traceCtx func(context.Context, string) context.Context) {
	for {
		switch frame := frame.(type) {
        case *http2.MetaHeadersFrame:
            //1. 读取底层tcp数据，最后进行解析
			if t.operateHeaders(frame, handle, traceCtx) {
				t.Close()
				break
			}
		case *http2.DataFrame:
			t.handleData(frame)
		case *http2.RSTStreamFrame:
			t.handleRSTStream(frame)
		case *http2.SettingsFrame:
			t.handleSettings(frame)
		case *http2.PingFrame:
			t.handlePing(frame)
		case *http2.WindowUpdateFrame:
			t.handleWindowUpdate(frame)
		case *http2.GoAwayFrame:
			// TODO: Handle GoAway from the client appropriately.
		default:
			if logger.V(logLevel) {
				logger.Errorf(&quot;transport: http2Server.HandleStreams found unhandled frame type %v.&quot;, frame)
			}
		}
	}
}

//对解码后的报头进行操作
func (t *http2Server) operateHeaders(frame *http2.MetaHeadersFrame, handle func(*Stream), traceCtx func(context.Context, string) context.Context) (fatal bool) {
    //2. 解析头数据
	if h2code, err := state.decodeHeader(frame); err != nil {
		return false
    }
    //grpc层的数据
    s := &amp;Stream{
		recvCompress:   state.data.encoding,
		method:         state.data.method,
		contentSubtype: state.data.contentSubtype,
    }
    //一个关键的ctx包含很多机制
    s.ctx

    //3. 根据解析后的头数据，进行一系列的设置
    //4. 设置：超时的ctx
	if state.data.timeoutSet {
		s.ctx, s.cancel = context.WithTimeout(t.ctx, state.data.timeout)
	} else {
		s.ctx, s.cancel = context.WithCancel(t.ctx)
    }
    
    //address
    pr := &amp;peer.Peer{
		Addr: t.remoteAddr,
	}
	s.ctx = peer.NewContext(s.ctx, pr)
	//5. 设置：metadata 存入context中
	if len(state.data.mdata) &gt; 0 {
		s.ctx = metadata.NewIncomingContext(s.ctx, state.data.mdata)
	}
	
	//6. 执行函数指针
	handle(s)
	return false
}


func (d *decodeState) decodeHeader(frame *http2.MetaHeadersFrame) (http2.ErrCode, error) {
    ...
    for _, hf := range frame.Fields {
		d.processHeaderField(hf)
    }
    ...
}


func (d *decodeState) processHeaderField(f hpack.HeaderField) {
	switch f.Name {
    case &quot;content-type&quot;:
        //如果类型 不包含 `application/grpc`  则抛异常，可以是`application/grpc;xxxx`等
		contentSubtype, validContentType := grpcutil.ContentSubtype(f.Value)
		if !validContentType {
			d.data.contentTypeErr = fmt.Sprintf(&quot;transport: received the unexpected content-type %q&quot;, f.Value)
			return
		}
		d.data.contentSubtype = contentSubtype
		d.addMetadata(f.Name, f.Value)
        d.data.isGRPC = true
    case &quot;:path&quot;:
        //依靠它找到需要调用的函数 比如/pb.TspService/Hello
		d.data.method = f.Value
    case &quot;grpc-timeout&quot;:
        //如果有超时设置，会创建ctx context.WithTimeout(t.ctx, state.data.timeout)
		d.data.timeoutSet = true
		var err error
		if d.data.timeout, err = decodeTimeout(f.Value); err != nil {
			d.data.grpcErr = status.Errorf(codes.Internal, &quot;transport: malformed time-out: %v&quot;, err)
		}
	default:
        //自定义的metadata在这里处理
		d.addMetadata(f.Name, v)
	}
}
</code></pre><h2 id=解析请求数据的细节>解析请求数据的细节 <a href=#%e8%a7%a3%e6%9e%90%e8%af%b7%e6%b1%82%e6%95%b0%e6%8d%ae%e7%9a%84%e7%bb%86%e8%8a%82 class="hash g">#</a></h2><ol><li><p>利用反射注册的函数，进行调用，参数传递，传递解析方式，但不会调用</p></li><li><p>调用到pb里注册的函数，在_TspService_Hello_Handler中进行具体处理</p><ol><li>解析请求信息</li><li>调用拦截器</li><li>拦截器过滤后，进行最终的函数调用</li></ol></li><li><p>源码</p></li></ol><pre><code class=language-go>//最终解析在这里
func _TspService_Hello_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HelloRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TspServiceServer).Hello(ctx, in)
	}
	info := &amp;grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: &quot;/pb.TspService/Hello&quot;,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TspServiceServer).Hello(ctx, req.(*HelloRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func (s *Server) processUnaryRPC(t transport.ServerTransport, stream *transport.Stream, info *serviceInfo, md *MethodDesc, trInfo *traceInfo) (err error) {
	df := func(v interface{}) error {
        //根据content-type 获取解析器，进行解析
		if err := s.getCodec(stream.ContentSubtype()).Unmarshal(d, v); err != nil {
			return status.Errorf(codes.Internal, &quot;grpc: error unmarshalling request: %v&quot;, err)
		}
		if sh != nil {
			sh.HandleRPC(stream.Context(), &amp;stats.InPayload{
				RecvTime:   time.Now(),
				Payload:    v,
				WireLength: payInfo.wireLength + headerLen,
				Data:       d,
				Length:     len(d),
			})
		}
		if binlog != nil {
			binlog.Log(&amp;binarylog.ClientMessage{
				Message: d,
			})
		}
		if trInfo != nil {
			trInfo.tr.LazyLog(&amp;payload{sent: false, msg: v}, true)
		}
		return nil
    }
 
    ctx := NewContextWithServerTransportStream(stream.Context(), stream)
    //利用反射进行函数调用
    //info.serviceImpl函数， ctx函数的第一个参数（metadata等信息），df请求数据（protobuf的解析）
    //s.opts.unaryInt 拦截器
	reply, appErr := md.Handler(info.serviceImpl, ctx, df, s.opts.unaryInt)

	opts := &amp;transport.Options{Last: true}

    //发送结果给请求方
	if err := s.sendResponse(t, stream, reply, cp, opts, comp); err != nil {
	
	}

	return err
}
</code></pre><h1 id=metadata>Metadata <a href=#metadata class="hash g">#</a></h1><p>Metadata是在一次 RPC 调用过程中关于这次调用的信息。 是 key-value的形式。其中 key 是 string 类型， value是[]string。</p><blockquote><p>Metadata 对于 gRPC 本身来说透明， 它使得 client 和 server 能为对方提供本次调用的信息。就像一次 http 请求的 RequestHeader 和 ResponseHeader，http header 的生命周期是一次 http 请求， Metadata 的生命周期则是一次 RPC 调用</p></blockquote><pre><code class=language-go>//grpc的结构
type MD map[string][]string
</code></pre><h3 id=使用>使用 <a href=#%e4%bd%bf%e7%94%a8 class="hash g">#</a></h3><ul><li>发送方</li></ul><pre><code class=language-go>    dd := metadata.Pairs(&quot;hello&quot;, &quot;world&quot;)
    ctx = metadata.NewOutgoingContext(ctx, dd)
    r, err := c.Hello(ctx, &amp;pb.HelloRequest{Msg: &quot;fff&quot;})
</code></pre><ul><li>接收方</li></ul><pre><code class=language-go>func (s *server) Hello(c context.Context, p *pb.HelloRequest) (*pb.HelloResponse, error) {
	md, _ := metadata.FromIncomingContext(c)
        fmt.Println(md.Get(&quot;hello&quot;))
}
</code></pre><h3 id=注意事项>注意事项 <a href=#%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9 class="hash g">#</a></h3><p>metadata本意是用来描述调用的信息的：协议的格式、调用方的请求方式、参数、非业务相关信息等。数据相关的不要用metadata进行存储。这样可以在不进行解析传输数据的情况下，依靠metadata进行一些逻辑处理，比如根据metatdata判断数据解析的方式、一些中间服务根据metadata信息，进行面向服务的操作。</p><h1 id=拦截器>拦截器 <a href=#%e6%8b%a6%e6%88%aa%e5%99%a8 class="hash g">#</a></h1><p>拦截器（Interceptor） 类似于 HTTP 应用的中间件（Middleware），能够让你在真正调用 RPC 方法前，进行身份认证、日志、限流、异常捕获、参数校验等通用操作，和 Python 的装饰器（Decorator） 的作用基本相同。</p><p>客户端发起请求前做一些验证，服务端处理消息前做过滤
grpc服务端和客户端都提供了interceptor功能</p><ul><li>client：发起请求前做统一处理</li><li>server：收到请求，进入具体执行函数之前，对请求做统一处理</li></ul><blockquote><p>调用方式类似链表、调用一个后再调用下一个节点</p></blockquote><h3 id=grpc源码>grpc源码 <a href=#grpc%e6%ba%90%e7%a0%81 class="hash g">#</a></h3><pre><code class=language-go>func NewServer(opt ...ServerOption) *Server {
    //..
	chainUnaryServerInterceptors(s)
	chainStreamServerInterceptors(s)
	//..
	return s
}

func chainUnaryServerInterceptors(s *Server) {
	if s.opts.unaryInt != nil {
		interceptors = append([]UnaryServerInterceptor{s.opts.unaryInt}, s.opts.chainUnaryInts...)
	}

	var chainedInt UnaryServerInterceptor
	if len(interceptors) == 0 {
		chainedInt = nil
	} else if len(interceptors) == 1 {
		chainedInt = interceptors[0]
	} else {
		chainedInt = func(ctx context.Context, req interface{}, info *UnaryServerInfo, handler UnaryHandler) (interface{}, error) {
			return interceptors[0](ctx, req, info, getChainUnaryHandler(interceptors, 0, info, handler))
		}
	}

	s.opts.unaryInt = chainedInt
}
</code></pre></div></main></body></html>