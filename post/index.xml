<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on LoveIt</title>
    <link>https://example.com/post/</link>
    <description>Recent content in Posts on LoveIt</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Wed, 21 Jul 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://example.com/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>gin源码</title>
      <link>https://example.com/post/2021/20210721-gin/</link>
      <pubDate>Wed, 21 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/post/2021/20210721-gin/</guid>
      <description>gin是go开发的一个开源高性能http框架，其主要是把go官方的net/http进行了扩展，前缀树实现了动态路由、支持了中间件、对请求信息进行封装方便用户层使用等。本文基于 gin v1.7.2版本
创建流程 一个Engine实例可以使用New 或者 Default进行创建，唯一区别就是Default默认增加了两个中间件：日志Logger(), panic捕获 Recovery()
初始化会初始化以下内容：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  //gin.go  engine := &amp;amp;Engine{ //默认的分组 	RouterGroup: RouterGroup{ Handlers: nil, basePath: &amp;#34;/&amp;#34;, root: true, }, FuncMap: template.FuncMap{}, RedirectTrailingSlash: true, RedirectFixedPath: false, HandleMethodNotAllowed: false, ForwardedByClientIP: true, RemoteIPHeaders: []string{&amp;#34;X-Forwarded-For&amp;#34;, &amp;#34;X-Real-IP&amp;#34;}, TrustedProxies: []string{&amp;#34;0.</description>
    </item>
    
    <item>
      <title>中国哲学简史</title>
      <link>https://example.com/post/read/20210710/</link>
      <pubDate>Sat, 10 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/post/read/20210710/</guid>
      <description>哲学家所说的宇宙是一切存在之全，相当于古代中国哲学家惠施所说的“大一”，其定义是“至大无外”。所以每个人、每个事物都应当看做宇宙的部分。当一个人思想宇宙的时候，他是在反思地思想
中国哲学的精神 入世与出世是对立的，正如现实主义与理想主义也是对立的一样。中国哲学的任务，就是把这些反命题统一成一个合命题。这并不是说，这些反命题都被取消了。它们还在那里，但是已经被统一起来，成为一个合命题的整体。如何统一起来？这是中国哲学所求解决的问题。求解决这个问题，是中国哲学的精神。
中国哲学家表达自己思想的方式 文字的明晰与暗示是不可得兼的。一种表达，越是明晰，就越少暗示；正如一种表达，越是散文化，就越少诗意。正因为中国哲学家的言论、文章不很明晰，所以它们所暗示的几乎是无穷的，不只是哲学，诗词也是如此，照中国的传统，好诗“言有尽而意无穷”。所以聪明的读者能读出诗的言外之意，能读出书的行间之意。中国艺术这样的理想，也反映在中国哲学家表达自己思想的方式里。
也因此读原文能直接面对作者暗示，读译文或者白话文则看到的是译者的揣摩所以非原文不可达其意
中国哲学的背景 1.地理位置 陆地辽阔 古代很少见海 2.经济背景 重本轻末 重视农业轻视商业
反者道之动 中庸之道 蔽于天而不知人 因为地理原因和经济背景导致中国人主要靠土地为生，所以几乎祖祖辈辈生活在一个地方，几代人都生活在一起，这样就发展起来了中国的家族制度
由于同样的原因，祖先崇拜也发展起来了。居住在某地的一个家族，所崇拜的祖先通常就是这个家族中第一个将全家定居此地的人。这样他就成了这个家族团结的象征，这样的一个象征是一个又大又复杂的组织必不可少的。
儒家学说大部分是论证这种社会制度合理，或者是这种制度的理论说明。经济条件打下了它的基础，儒家学说说明了它的伦理意义。由于这种社会制度是一定的经济条件的产物，而这些条件又是其地理环境的产物，所以对于中华民族来说，这种制度及其理论说明，都是很自然的。因此，儒家学说自然而然成为正统哲学，这种局面一直保持到现代欧美的工业化侵入，改变了中国生活的经济基础为止。
入世出世</description>
    </item>
    
    <item>
      <title>资治通鉴 卷1-16</title>
      <link>https://example.com/post/%E8%B5%84%E6%B2%BB%E9%80%9A%E9%89%B4/1/</link>
      <pubDate>Wed, 16 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/post/%E8%B5%84%E6%B2%BB%E9%80%9A%E9%89%B4/1/</guid>
      <description>卷一  司马光引孔子的话：&amp;ldquo;天尊地卑，乾坤定矣。卑高以陈，贵贱位矣。&amp;ldquo;认为君臣关系就像天地一样不能互换。如果不是桀、纣那样的暴君，对手又是商汤周武王那样的明主，君臣的名分本是不可变的。孔教里名分很重要，孔子把名分看的很重要：&amp;ldquo;卫君待孔子而为政，孔子欲先正名，以为名不正则民无所措手足。&amp;quot;。三家分晋，周天子不但不征讨，反而加封赐爵。这是周天子自己破坏了礼教，礼教坏了，天下大乱，诸侯国才开始争雄称霸，才有了战国开始。
 这么看来礼教三钢确实是束缚人的道德，帝王利用它可以教化民众，人生下来就不能反抗。陈胜能在当时说出&amp;quot;王侯将相宁有种乎？&amp;quot;还是真厉害啊，怪不得毛主席说五帝三皇神圣事，骗了无涯过客。有多少风流人物？盗跖庄屩流誉后，更陈王奋起挥黄钺
  赵简子为了立太子，把训诫的竹简给俩儿子，让他们谨记。三年后问他们内容，长子伯鲁说不清，简也丢了；二子无恤不但能背诵，还把简随身带着，放在袖子里。最后无恤成了太子。
 无恤天天带着是不是有点假，竹简好像挺沉的吧？不过如果是真的，那天天带着证明有毅力；如果是假的赵简子问的时候他靠其他途径得知再带上，证明他奸；无论怎样在当君主方面都比老大强
  智宣子立智瑶为后，瑶有才但心不仁。即位后总依靠国力强盛欺辱其他国家君主，在宴席上羞辱戏弄韩康子；向韩康子、魏恒子索要领土，两家都给了，其实这都是两家的计谋 《周书》曰：将欲败之，必姑辅之。将欲取之，必姑与之。以骄智伯，然后可以择交而图智氏矣。最后果不其然瑶更加得寸进尺又找赵襄子无恤要领土，赵襄子拒绝，智瑶怒，率韩、魏攻伐。最后反被三家联合起来灭了智氏一族。
 将欲败之，必姑辅之。将欲取之，必姑与之； 德行很重要
  三家分智氏之田后，智伯家臣豫让想报仇，未遂。赵襄子认为他是义士就放了他。豫让还没放弃，装扮成病人，吞下炭火弄哑嗓音，每天上街乞讨，寻找机会，连妻子都认不出。有一次遇到了好友，他一眼认出了，流着泪说：以你的才干，为什么不投靠赵家，找机会报仇，为什么非要这么做呢？豫让说：&amp;quot;既已委质为臣，而又求杀之，是二心也。凡吾所为者，极难耳。然所以为此者，将以愧天下后世之为人臣怀二心者也。&amp;quot;。最后复仇失败，被杀。
 真义士也，虽然看着有些’蠢‘，但我很敬佩。
  魏文侯儿子子击驾车遇到田子方，下车伏拜行礼，子方却不回礼。子击生气的说：&amp;ldquo;你说富贵的人能对人骄傲，还是贫贱的人能对人骄傲？&amp;quot;。田子方说：&amp;quot;亦贫贱者骄人耳！富贵者安敢骄人！国君而骄人则失其国，大夫而骄人则失其家。失其国者未闻有以国待之者也，失其家者未闻有以家待之者也。夫士贫贱，言不用，行不合，则纳履而去耳，安往而不得贫贱哉！&amp;quot;。于是子击作揖道谢
 光脚的不怕穿鞋的
  韩国国相侠累与濮阳人严仲子有仇。严仲子听说聂政是个勇猛之人，献巨金为其母庆寿，结为好友，求其为己报仇。但聂政说：&amp;ldquo;老母还在，需要赡养，不能献身&amp;quot;拒绝了。等到母亲去世后，聂政为报与严仲子知遇之恩，一人一剑刺杀了侠累，但周围都是兵卫，无法逃脱，于是用剑毁了自己的面容，并自杀了。韩国人将他尸体放到集市，悬赏追查此人，但没人知道。聂政的姐姐聂荌听说了此事，立刻前往，哭着说：&amp;ldquo;这就是聂政啊，他是因为我这个姐姐还在不想连累我，才自毁面容的，但我怎么能为了自己性命埋没了弟弟的英明呢&amp;rdquo;，于是自尽死在了聂政的身边。
 姐弟俩都是英烈，真感人
卷二 </description>
    </item>
    
    <item>
      <title>关于矛盾论</title>
      <link>https://example.com/post/read/20210613/</link>
      <pubDate>Sun, 13 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/post/read/20210613/</guid>
      <description> 辩证法研究对象的本质自身中的矛盾 &amp;ndash; 列宁
 从这句话得知矛盾是辩证法的核心。因为是核心，所以涉及许多方面和哲学问题：两种宇宙观、矛盾的普遍性、矛盾的特殊性、主要矛盾和主要矛盾的方面、矛盾诸多方面的同一性和斗争性、对抗在矛盾中的地位。
两种宇宙观 主要有两种宇宙观，一种是形而上学的见解，一种是辩证法的见解。
 由于欧洲许多国家的社会经济情况进到了资本主义高度发展的阶段，生产力、阶级斗争和科学均发展到了历史上未有过的水平，工业无产阶级成为历史发展的最伟大的动力，因而产生了马克思主义的唯物辩证法的宇宙观。于是，在资产阶级那里，除了公开的极端露骨的反动的唯心论之外，还出现了庸俗的进化论，出来对抗唯物辩证法
 上面这句话怎么理解？我认为是资本主义因为社会的发展达到了绝对的高度，冲破了封建社会的枷锁，而工人阶级是资本主义的产物，帮助资本主义打破封建奴隶社会，这样才能方便资本扩张，于是创造了世界通史。证明了过去几千年的封建社会不会是永远存在的，总会因为内部外部的条件激化发生改变，因而给唯物辩证法带来了充分的证明。根据唯物辩证法，事物的发展是对立统一的，不会一成不变，这样的话资产阶级获得了利益，当然要防止这种思想吧。
形而上学的宇宙观就是用孤立的、静止的、和片面的观点去看世界，这种宇宙观把世界一切事物，一切事物形态和种类，都看成永远彼此孤立和永远不变话。如果有变化只是数量和场所的变更。而且是由外因而不是事物内部导致的。按照这种思想，资本主义应当是自古至今一直存在，且未来也会存在的。
唯物辩证法的宇宙观是从事物内部和与其他事物的关系去研究事物的发展。事物发展的第一根本原因是内部矛盾性，第二原因是和其他事物互相联系互相影响。和形而上学相比，单纯的外部因素只能引起事物的机械运动：范围大小、数量变化等。无法说明事物何以有性质上的千差万别及其互相变化。另外即便是外部因素的变化也依靠的是事物内部矛盾性。
 外因是变化的条件，内因是变化的根据，外因通过内因起作用
 举个例子：鸡蛋因合适的温度(外因)变成鸡，但温度不能让石头变成鸡(内因是变化的根据)，温度能影响鸡蛋不能影响石头因为二者的根据（内部本质）是不同的。
另外一个例子：俄国十月革命开创了俄国新纪元，也影响了其他国家，中国也因此发生了内部的革命。这也说明事物之间是会互相关联影响的。
以上对比了形而上学和唯物辩证法的区别。形而上学看事物是：孤立、静止的，因此事物只有数量和场景上的变化，无质变；辩证法看事物是：互相关联影响的，事物变化主要依靠内部因素和外部条件，所以会产生质变。
 辩证法的宇宙观，不论在中国，在欧洲，在古代就产生了。但是古代的辩证法带著自发的朴素的性质，根据当时的社会历史条件，还不可能有完备的理论，因而不能完全解释宇宙，后来就被形而上学所代替
 为什么唯物辩证法到了近代才有影响力？随着科学、社会的进步资本的扩张对世界有了更深层更全面的认识，再加上马克思、恩格斯、列宁斯大林等对唯物辩证法的发展才能有所成就。
 主要地就是教导人们要善于去观察和分析各种事物的矛盾的运动，并根据这种分析，指出解决矛盾的方法
 辩证法的宇宙观有什么作用呢？我们可以根据事物的发展，找出其中的规律，找到核心的矛盾点，找到问题，才能解决问题
矛盾的普遍性 矛盾的普遍性或者说绝对性有两方面意义：
 矛盾存在于一切事物的发展过程中 每一事物的发展过程中存在著自始至终的矛盾运动  矛盾存在于一切事物的发展过程中  矛盾是简单的运动形式的基础，更是复杂的运动形式的基础
 根据上面的话，无论是自然、精神、社会都有互相对立矛盾的趋势。在力学中，作用和反作用。在物理学中，阳电和阴电。在化学中，原子的化合和分解。在社会科学中，阶级斗争。因为有了矛盾，才能解决矛盾，解决了矛盾才能使得事物发展甚至发生质变，才有了向上的朝气，一旦矛盾消失，事物的生命周期也就终结了。由此看来，不论是简单的运动形式，或复杂的运动形式，不论是客观现象，或思想现象，矛盾是普遍地存在著，矛盾存在于一切过程中
每一事物的发展过程中存在著自始至终的矛盾运动 既然矛盾存在于一切事物的发展过程中，那么每一过程的开始阶段，是否也有矛盾存在呢？是否每一事物的发展过程具有自始至终的矛盾运动呢？答案是有的。
如果说事物发展的开始不是内部矛盾，而是由外部矛盾导致，那就回到了形而上学的宇宙观去了。世界上的每一差异中就已经包含矛盾，差异就是矛盾，比如劳资之间，从一开始就有了矛盾，只是还没有被激化，他们的差异性就是矛盾。
 新过程的发生是什么呢？这是旧的统一和组成此统一的对立成分让位于新的统一和组成此统一的对立成分，于是新过程就代替旧过程而发生。旧过程完结了，新过程发生了。新过程又包含著新矛盾，开始它自己的矛盾发展史
  “马克思在《资本论》中，首先分析的是资产阶级社会(商品社会)里最简单的、最普通的、最基本的、最常见的，最平常的，碰到亿万次的关系&amp;mdash;-商品交换。这一分析在这个最简单的现象中(资产阶级社会的这个‘细胞’之中)暴露了现代社会的一切矛盾(以及一切矛盾的胚芽)。往后的叙述又向我们表明了这些矛盾和这个社会各个部分总和的自始至终的发展(增长与运动两者)。”
  这应该是一般辩证法的&amp;hellip;&amp;hellip;叙述(以及研究)方法。
 那一般辩证法的研究和叙述方法是什么？找到事物发展的最核心现象，从现象出发，找到其中的矛盾，然后分析这些矛盾和现象各个部分总和和自始至终的发展，这样就能正确分析历史和现状，并推断将来。
矛盾的特殊性 主要矛盾和主要矛盾的方面 矛盾诸多方面的同一性和斗争性 对抗在矛盾中的地位 </description>
    </item>
    
    <item>
      <title>管理什么的</title>
      <link>https://example.com/post/read/20210610/</link>
      <pubDate>Thu, 10 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/post/read/20210610/</guid>
      <description>小团队的话，管理者个人开发能力过关，再加上分配工作合理就能有不错的效果。再进一步就是把项目规划好，在项目进展中及时纠正错误问题（计划、设计、工作分配等），及时反馈问题（技术不可达），做好与其他部门的协作。这应该会是一个不错稳定的团队。
一个团队想要发展除了保持上面的内部优点，还需要多做一些对外的输出。将自己内部孵化的技术、文档、规范等推广到公司其他部门，这样的话团队不只是一个盈利点，还是能为公司整体带来更大收益面。那么如何才能对外输出呢？我现在能想到的只有技术相关，所以只说一下技术方面，比如良好的代码管理，良好的架构设计，业务的解耦，可以让很多技术点独立化，达到拿来就用，这样可以使全部的开发团队受益，而不必重复造轮子；良好的文档管理，文档规范，再加上刚才说的良好的代码，可以让其他团队迅速了解并进入我们的团队，达到团队之间的互通，使得技术松耦合，团队高内聚；如此我认为可以成为一个比较优秀的团队。
一个优秀的团队，可以为公司带来不只一方面的好处（只是完成一个项目的好处），还能带来上面说的为整体提升。也因此可以让公司发展更加健康（良好的人员结构，良好的技术基础）可以让产品迭代更新更迅速。这时候团队想做大，我认为主要依靠一个良性循环，公司因有好的团队变得健壮，团队因为公司的迅速成长，水涨船高变得越来越壮大。这时候需要把重点多分配到人员管理上，对员工有更好的福利，招聘更优秀的人，因为程序员做的不是体力活，人多不一定力量大。并且管理者也应该从开发前线，多拿出一些时间放到整体技术把控和人员管理上。这么说来，我认为一个大而强的团队除了主观因素（内部健康发展）还需要客观因素（公司整体素质）才可以吧。</description>
    </item>
    
    <item>
      <title>grpc-go</title>
      <link>https://example.com/post/2021/20210119-grpc/</link>
      <pubDate>Tue, 19 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/post/2021/20210119-grpc/</guid>
      <description>grpc Server 本文简单阅读源代码，了解grpc server的执行流程，从建立连接，到处理一条请求的过程。
使用方式 使用方式很简单，生成pb，注册建立服务，就可以等待请求了
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  type Hello struct{ } func (h *Hello) Say(ctx context.Context, request pb.HelloRequest)(*pb.HelloResponse, error){ fmt.Println(request.Msg) return &amp;amp;pb.HelloResponse{Msg: &amp;#34;wwww&amp;#34;}, nil } func main(){ lis, _ := net.Listen(&amp;#34;tcp&amp;#34;, &amp;#34;127.0.0.1:8888&amp;#34;) //1. 创建一个grpc服务器对象  gRpcServer := grpc.NewServer() //2. 注册pb函数  pb.RegisterHelloServiceServer(gRpcServer, &amp;amp;Hello{}) //3. 开启服务端  //阻塞  gRpcServer.Serve(lis) }   建立grpc server流程 NewServer NewServer进行创建一个grpc服务，初始化一些参数。还可以进行函数选项模式，来传递初始化的配置。 默认情况下会建立一个以下参数的grpc服务：</description>
    </item>
    
    <item>
      <title>计算机网络-传输层</title>
      <link>https://example.com/post/2021/20210105-tcpudp/</link>
      <pubDate>Tue, 05 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/post/2021/20210105-tcpudp/</guid>
      <description>TCP/IP 模型 应用层将数据传递给传输层，传输层将数据分段，每段加入自己的首部数据，然后传递给下一层，之后的每层都会封装上自己层需要的首部，最后经过物理链路传递到指定主机，然后每层又向剥洋葱一样，一层层处理自己的首部数据，到达传输层，传输层最终交付给应用程序。 数据传输流程： 传输层 与应用层的关系：应用层将数据发送给传输层，传输层将其进行分段处理，每段数据加入头协议，然后将每组发出去 与网络层的关系：分组的数据发给网络层，网络层将数据真正的发给链路层，然后从物理链路发到指定服务的进程中去
举例： 北京一个家庭： 小明家庭 天津一个家庭： 小红家庭 小明写了封信，交给管家，管家将信给邮政局，邮政局收到后，寄到天津小红家，管家将信给小红；
小明家庭的任意成员写信-&amp;gt;小明家的管家-&amp;gt;邮局-&amp;gt;小红家的管家-&amp;gt;小红
应用层数据：小明信的内容 进程：小明，小明家庭成员都是这个主机内所有进程。 主机：小明的家庭 和 小红的家庭 传输层：管家，每个主机有一个管家 网络层：邮局
简单介绍udp tcp tcp将应用层数据，分段处理 称为 报文段（seg-ment)；upd将应用层数据，分段处理 称为 数据报。 IP层 网际协议，为主机之间提供逻辑通信，尽力而为的交付服务（best-effort delivery service) 所以不保证数据不会丢失，报文段的顺序，并且附带了一个唯一表示的地址也就是ip地址来进行主机之间的确认。 udp和tcp 的基本责任是对两个端系统间的进程进行交付服务。主机间交付扩展到进程间交付被称之为 传输层的多路复用和多路分解。 并且都提供了差错检查字段，来对完整性进行校验。而udp也是不可靠服务，所以它仅提供了这两种服务：差错校验和进程到进程之间的交付。 tcp提供了可靠传输，通过流量控制，序号，确认，定时器等确保数据正确的，有序的到达接收进程;还提供了拥塞控制，调节网络流量速率，为整个互联网代理通用的好处，提供平等的带宽，这也是udp的传输速率高于tcp原因之一。
对于拥塞控制可以举个例子：拥塞控制如同交通规则，当车辆很多的情况下，大家都遵守交通虽然会降低一点开车速度。但对整个城市的交通提供了高效的运转，一辆辆tcp汽车，会公平的遵守交通达到目的地。而一辆udp汽车运行其中不遵守交规，在车辆少的情况下，是绝对高速的，但高峰期的时候绝对会出现各种事故（丢包率提高等）
多路复用，多路分解 多路复用:一个主机有多个进程，每个进程为了通信会建立一个套接字（socket)，而一个主机只有一个传输层，所以多个socket将数据传输给传输层，传输层将这些数据进行封装上首部信息（为了以后的分解）从而生成报文段。然后将报文段传递给网络层，这个过程就是多路复用。
多路分解:当主机收到其他主机的数据，传输层根据报文段的首部信息找到指定的socket。这个过程就是多路分解
举例：依旧是上面的例子，当管家收到信件后，需要依靠信件上的名字，给指定的成员（小明，爸爸，妈妈）。 这个管家的操作就是多路分解。当成员（小明，爸爸，妈妈）写了信给管家，管家进行整理然后发送给邮政局，这个管家的操作就是多路复用
通过上述描述，传输层的多路复用的要求是：
 每一个套接字要有唯一的标识，否则传输层无法分辨该将数据给谁 每个报文段要有特殊的字段来标识，要交付给哪个套接字（也就是端口 port）  1 2 3 4 5 6 7  |-----------------| | 源端口 | 目的端口 | |-----------------| | 其他首部字段 | |-----------------| | 应用数据 | |-----------------|   udp的多路复用的多路复用/分解 一个udp套接字使用一个二元组来全面标识，该二元组包含：一个目的IP地址和一个目的端口号。这也是为什么多个客户端连会接到同一个服务进程的同一个套接字</description>
    </item>
    
    <item>
      <title>MIT6.828 - 02-Lab1.Util</title>
      <link>https://example.com/post/2020/20200407-mit6.828-02-lab1/</link>
      <pubDate>Tue, 07 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/post/2020/20200407-mit6.828-02-lab1/</guid>
      <description>实验说明 每一个Lab对应一个git 分支，本实验分支为 util，主要是实现5个命令程序。在 xv6-riscv-fall19项目里， kernel是内核， user是用户态程序， 代码写到user里，然后再Makefile UPROGS变量中加入的相应名称即可：
1 2 3 4 5 6  UPROGS=\ 	$U/_sleep\ 	$U/_pingpong\ 	$U/_primes\ 	$U/_find\ 	$U/_xargs\   我的实验代码都在 自己fork的仓库里
执行make grade会测试自己写的api，如果执行失败可能是未安装python(apt-get install python)，就像下面一样：
1 2 3 4 5 6 7 8  $ make qemu-gdb OK (5.1s) sleep, returns: $ make qemu-gdb OK (1.1s) sleep, makes syscall: $ make qemu-gdb OK (0.7s)   执行 make 然后 make qemu 编译运行操作系统</description>
    </item>
    
    <item>
      <title>MIT6.828 - 01.环境搭建</title>
      <link>https://example.com/post/2020/20200406-mit6.828-01/</link>
      <pubDate>Mon, 06 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/post/2020/20200406-mit6.828-01/</guid>
      <description>概述 6.S081 目标  理解操作系统设计与实现 掌握扩展迷你操作系统的实践经验 掌握编写系统软件的经验  环境搭建 我使用docker进行环境搭建，构建自己的image，方便部署，之后换电脑也无需重复安装各种工具。 我的image: docker pull zuojxin/xv6 (image太大了，应该是可以优化的)
docker 简单命令  创建自己的docker：docker build -t orige_name/image_name:tag 安装镜像：docker pull image_name 删除镜像：docker rmi image_name 删除容器：docker rm container_name 查看已安装镜像：docker images 启动镜像容器： docker run -t -i image_name:tag 保存容器：docker commit container_id image_name 上传镜像：docker push image_name:tag 本地文件拷贝到docker容器：docker cp 文件 container_id:容器内路径 精简image大小：http://www.dockerinfo.net/3328.html 清理docker缓存：https://blog.fundebug.com/2018/01/10/how-to-clean-docker-disk/  Dockerfile 1 2 3 4 5 6 7  FROMdebianLABEL xv6 &amp;lt;zuojxin@docker.com&amp;gt;RUN apt-get update RUN apt-get -y install git build-essential gdb-multiarch qemu-system-misc \  gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu  RUN git clone https://github.</description>
    </item>
    
    <item>
      <title>MIT6.828 - 00.开始</title>
      <link>https://example.com/post/2020/20200405-mit6.828-00/</link>
      <pubDate>Sun, 05 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/post/2020/20200405-mit6.828-00/</guid>
      <description>前言 写一个操作系统一直是我的梦想，MIT 6.828-2019fall是最好的课程之一。我将记录学习的过程与实践， 所有代码都会上传至我的github
目录 LEC 1: 环境搭建 &amp;amp; Lab1:Util
主要学习的资料 官方讲义
xv6 文档
xv6源码
vx6源码分析
其他参考：
https://blog.mky.moe/
https://blog.csdn.net/bysui/category_6232831.html
https://www.cnblogs.com/fatsheep9146/category/769143.html
  </description>
    </item>
    
    <item>
      <title>源码阅读 - go Context</title>
      <link>https://example.com/post/2020/20200401-go-context/</link>
      <pubDate>Wed, 01 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/post/2020/20200401-go-context/</guid>
      <description>Context有什么用 当处理一个请求A，而这个请求需要在3秒内完成相应，A请求分别创建了B和C goroutine来处理逻辑，如果B或者C处理时间过长超过了3秒，那么继续执行显然是没必要且浪费资源。这时候就需要一个能终止他们的操作，而go没有提供类似 goroutineID这样的变量来记录goroutine状态。官方认为这样非常容易被滥用。所以Context就为此而来。
 利用 channel/select ，以信号的方式来通知需要停止的goroutine 可以为Context记录一个key/value 来包含一些请求相关的信息  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  func B(ctx context.Context) error { for { select { case &amp;lt;-time.After(1 * time.Second): fmt.Println(&amp;#34;hello B&amp;#34;) case &amp;lt;-ctx.Done(): fmt.Println(&amp;#34;b is end&amp;#34;) return ctx.</description>
    </item>
    
    <item>
      <title>百年孤独</title>
      <link>https://example.com/post/2020/20200210-book-%E7%99%BE%E5%B9%B4%E5%AD%A4%E7%8B%AC/</link>
      <pubDate>Mon, 10 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/post/2020/20200210-book-%E7%99%BE%E5%B9%B4%E5%AD%A4%E7%8B%AC/</guid>
      <description>第一章 简要 一个叫 何塞·阿尔卡蒂奥·布恩迪亚 的人，从吉卜赛人 梅尔吉亚德斯，一个诚实善良的人手中换来各种新奇未见过的道具：磁铁，放大镜等。 他天马行空，爱钻研，专注，却又有些愚蠢，这些道具在他手中没有按他所想如意，结果让自己变得抑郁寡欢，曾经的他带领人们寻找安家之所，他和妻子是全村的楷模，如今痴迷于科学，变得慵懒不修边幅。但他却根据吉普赛人的知识，自己研究出了 地球是圆的，在当时难以置信的超前想法。没多久他的好友梅尔吉亚德斯病逝，之后来了 另一批吉普赛人，他第一次见到，抚摸到冰。
人物关系 何塞·阿尔卡蒂奥·布恩迪亚
 妻子 乌尔苏拉·伊瓜兰 大儿子 小何塞·阿尔卡蒂奥 小儿子 何塞·奥雷里亚诺·布恩迪亚 吉普赛人 好友 买卖道具 梅尔吉亚德斯  第二章 简要 何塞与乌尔苏拉是表亲，不敢生子，怕出畸形，却被村中的普鲁邓希奥·阿基拉尔耻笑，一怒之下何塞用长矛杀死了他。也因此不再惧怕生子，但良心的谴责，被迫他们远离村子，去其他地方。何塞的很多朋友也因探险欢呼加入他们。就这样奔波几个月，建立了马孔多。 大儿子 何塞·阿尔卡迪奥 鸡鸡很大，他年纪不大的时候和 庇拉尔·特尔内拉 发生关系。这女人是和她母亲年龄相仿，曾参加建立马孔多远征的人。 与她在一起，他感到担忧又充满欲望，并将此事告知弟弟。不久特尔内拉告诉他：“你要当父亲了”，他才从幻梦中惊醒，不再想情爱，而是担忧，想脱离现实。 在吉普赛人来到村子，他又与一位年龄很小，很美的吉普赛人一见钟情，发生关系，并随吉普赛人偷偷离去，远离家乡。
儿子失踪，母亲连忙追寻，父亲依旧炼金，小儿子 奥蕾里亚诺知道缘由，反感特尔内拉。 母亲在失踪几月后，归来。儿子没找到，却扎到了丈夫在失败的远征中没能发现的通向伟大发明的道路。和他们一样的村民，这些村民比他们生活的更好，见惯了各样改善生活的机器。
言语 何塞·阿尔卡掉：“我想和你单独在一起，总有一我要把这一切告诉所有人，用不着躲躲藏藏。”
特尔内拉：“那太好了，要是能单独在一起，我们就可以点亮灯，互相能看见，而且我想怎么叫就怎么叫，不用管别人，你在我耳边想说什么就说什么。”
人物 环境  三女儿 阿玛兰妲 马孔多 何塞·阿尔卡蒂奥·布恩迪亚，带领人安札定居的村落 庇拉尔·特尔内拉 大儿子的情人  第三章 简要 特尔内拉生了儿子，何塞阿尔卡蒂奥布莱迪恩 坚持抚养，名叫 阿尔卡迪奥。 家里收留了 比西塔西翁姐弟，来照料孩子和家务。他们是为了逃避部落的失眠症来到了马孔多。 过了不久，几位皮草商人，带来了一位孤儿交给何塞一家，她是乌尔苏拉的挚友 尼卡诺尔·乌略亚和妻子丽贝卡·蒙铁尔 的女儿。此女一直行为古怪，过了很久才融入家里，不在那么古怪。但不久失眠症袭击了整个村落，全民无法入眠，并且记忆力越来越差，这时梅尔吉亚德斯来了，他用一种药水拯救了村子。他没死，难忍孤独的他又重返人间，和何塞重温昔日友情。 奥利里亚诺想买下妓女，有欲望有怜悯，有冲动，想保护她，当他作出决定去卡塔里诺店时，姑娘已经离开了镇子。他感到挫败，用工作逃避，决心远离女人来遮掩自己无能带来的羞耻。梅尔吉亚德斯语言马孔多会变成一座光明的城市，矗立着玻璃建造的高楼大厦，却不再有布恩迪亚家的丝毫血脉。乌尔苏拉设计并找人建造了马孔多最大的房子，来为家人居住，但镇里的里正下令要求 房子必须刷蓝色漆。何塞和马孔多的创建者们决定驱逐外来者，不该由外人管理马孔多。 何塞看在摩斯科特家人的份上，和平解决。奥蕾莉亚诺看见里正的9岁女儿蕾梅黛丝后就爱上了她。
言语 “我宁愿掂起一个活人，也不愿后半辈子都惦着一个死人”
“但她的影子正折磨着他身体的某个部位，那是一种肉体上的感觉，几乎在他行走时构成障碍，就像鞋子里进了一粒小石子”
人物  里正 堂阿波利纳尔·摩斯科特 政府派来监管 马孔多的官 安帕萝 是 堂阿波利纳尔·摩斯科特女儿 16岁 蕾梅黛丝 是 堂阿波利纳尔·摩斯科特女儿 9岁 丽贝卡 一位孤儿 她是乌尔苏拉的挚友尼卡诺尔·乌略亚和妻子丽贝卡·蒙铁尔 的女儿 比西塔西翁姐弟 何塞家的佣人 阿尔卡蒂奥·何塞 长子何塞阿尔卡蒂奥和特尔内拉的孩子  第四章 简要 新家建好，乌尔苏拉订购了很多家具，还有一台自动钢琴，一位意大利技师 皮埃特罗·克雷斯皮调试，安装钢琴，还教贝丽卡和阿玛兰妲跳舞，两女都爱上了他。贝丽卡对他的思念让她再次涌现出童年爱吃土的习惯，奥雷里亚诺此时对蕾梅黛丝的爱意愈加强烈，家中弥漫爱情瘟疫。奥雷里亚诺和马格尼菲科·比斯巴勒和豪里内勒多·马尔克斯去了卡塔里诺的店里寻欢，之后与庇拉尔·特尔内拉发生了关系，特尔内拉叶了解的奥雷里亚诺的痛苦，保证会帮他实现。当家里人知道了孩子们被爱所困扰，做出了妥协，去堂阿波利纳尔·摩斯科特家提亲，贝丽卡成了克雷斯皮的未婚妻，但阿玛兰妲憎恨这件事，发誓阻止他们的婚事。 梅尔吉亚德斯去世了，死前说“我已达到了永生”。全村为他举行了隆重的葬礼。何塞开始抛弃炼金研究起了 克雷斯皮带给他的神奇的机械玩具。而特尔内拉怀孕了，是奥雷里亚诺的孩子。何塞不眠不休的研究机械，在一天失眠的夜里看见了 普鲁邓希奥·阿基拉尔，这个当年被他杀死的男人。他们不再是冤家，而一直聊到天亮。但之后何塞向中了邪一样，语无伦次还捣毁家里，最后被人捆绑在树上。</description>
    </item>
    
    <item>
      <title>读CSAPP(4) - 虚拟内存</title>
      <link>https://example.com/post/2019/20190928-csapp4/</link>
      <pubDate>Sat, 28 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/post/2019/20190928-csapp4/</guid>
      <description>虚拟内存系统解决了物理寻址的缺点。利用内存管理单元（MMU）和页表（Page Table）将虚拟地址转换为物理内存地址。 进程运行过程不再加载全部数据，而是只保留当前运行需要的数据在内存中。为了让MMU更高效加入了TLB，缓存映射关系，还利用多级页表降低页表内存占用有了
虚拟内存系统 计算机系统主存被组织成一个连续字节大小的数组，每一个数组成员都有一个唯一的物理地址（Physical Address） 早期计算机使用物理寻址方式，这样的坏处是
 系统中多个进程所使用的内存，进程之间容易互相读写数据造成各种问题 每个进程内存分布不同，管理不便 进程中暂无用处的数据也会被加载，进程过多就会导致内存不够用  现代处理器使用虚拟寻址（Virtual Address），利用虚拟地址映射成物理地址再进行访问，解决了上面的主要问题。既然需要地址转换，这就需要内存管理单元（Memory Management Unit，MMU）和页表（Page Table，PT）来处理
 因为每个进程都有统一的访问方式，这样进程之间也不会互相影响 内存管理更加简单，每个进程看起来都在独享全部内存 节省内存空间，利用内存分页，物理内存中只保留进程当前活动区域，并根据需要在磁盘和主存之间来回传送数据  页表 虚拟内存系统将虚拟内存分割成一个个大小相同的虚拟页（Virtual Page，VP），类似的物理内存也被分割成物理页（Physical Page，PP）大小和VP相同，物理页也被称为叶帧（Page Frame）。 页表其实就是一个数组，每个元素称为页表项（Page Table Entry，PTE），PTE负责把虚拟页映射到磁盘或者物理页上。
任意时刻虚拟页面的集合都分为三个不想交的子集：
 未分配的：VM系统还未分配的页，物理内存，磁盘都没有与之关联的数据（图中0，3） 已分配已缓存的：已分配到了物理内存中（图中1，4，6） 已分配未缓存：数据块存在于磁盘中，还未被加载到内存（图中2，5，7）  页表项 当MMU从PTE获取物理内存地址，要根据PTE知道：
 虚拟页是否被缓存了 缓存命中需要知道具体存在于哪个物理内存页中 缓存未命中需要知道此虚拟页在磁盘的什么地方进行缓存替换操作  整个页表数据结构由操作系统进行负责维护，以及在磁盘与主存之间来回传送页，进行替换的时候需要向系统内核发送一个缺页异常，内核会做一些处理。 PTE负责把虚拟页映射到磁盘或者物理页上，假设需要两个数据：
 地址字段：存放映射的地址 有效位：判断此页是否被缓存  有了这两个字段就可以进行判断：
 设置了有效位，地址字段不为空：数据缓存在物理内存页中，地址字段为物理页的起始位置 没有设置有效位，地址字段为空：此虚拟页还未被分配 没有设置有效位，地址字段不为空：虚拟页被分配，但还未缓存到物理内存中，只在磁盘上，地址字段指向该虚拟页在磁盘上的起始位置  映射流程 虚拟地址有两部分VPN+VPO。MMU利用VPN找到对应的PTE， 例如 VPN 0 对应 PTE 0，找到PTE后，PTE中的有效位决定是否有效，是否需要缺页处理。 如果有效，则得到其中的PPN，使用PPN+VPO 得到最终的物理内存地址
页面命中，cpu硬件流程：
缺页流程，页面命中完全由硬件处理，处理缺页需要硬件和操作系统内核协作完成：
虚拟内存系统带来的优势 权限控制 每个PTE（页表项）高位部分存储了表示权限的位，MMU通过检查这些位来进行权限控制（sup表示进程是否必须运行在内核（超级管理员）模式下才能运行）。 如果违反了权限cpu会触发一个 一般保护故障，将控制传给内核的异常处理程序，linux shell一般称之为段错误（segmentation fault） 节省内存 MMU根据虚拟地址读取页表，发现设置了有效位，表明缓存命中，地址字段存储了物理页地址，就可以找到数据在物理内存中的位置，这是页命中，相对的就会触发缺页异常（缓存不命中 page fault）： （见上图）</description>
    </item>
    
    <item>
      <title>读CSAPP(3) - 存储器层次结构</title>
      <link>https://example.com/post/2019/20190923-csapp3/</link>
      <pubDate>Mon, 23 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/post/2019/20190923-csapp3/</guid>
      <description>了解硬件 随机访问存储器（Random-Access Memory，RAM） RAM分两类，静态（SRAM）的和动态的（DRAM），SRAM要比DRAM更快，价格也更高。 SRAM用于高速缓存存储器，可以在cpu芯片上，也可以在片下。DRAM用来作为主存以及 图形系统的帧缓冲区。无论哪种RAM一旦断电，所有信息都会丢失。
磁盘存储 磁盘存储数据的数量级更大，比RAM大得多，但读取信息要比DRAM慢10w倍，比SRAM慢100w倍。 磁盘分为机械硬盘和固态硬盘，机械硬盘的读写速度要低于固态硬盘，但价格低廉。
总线 IO总线：例如，鼠标键盘，图形卡，磁盘等设备连接的称为io总线 cpu使用内存映射I/O技术（memory-mapped I/O）来向I/O设备发起命令
 使用内存映射技术向io设备发起命令 磁盘控制器接收到命令，读取扇区，并执行到主存的DMA传送，磁盘进行直接内存访问的操作叫做DMA（Direct Memory Access） DMA传送完毕，磁盘控制器用中断方式通知cpu cpu接收到中断信号，从内存读取缓存的数据  局部性 一个好的程序应该有良好的局部性，这样可以使得效率更快
 时间局部性：被引用过一次的内存，很可能在不久的将来再次被引用多次 空间局部性：如果一个内存位置被引用了一次，那么程序再不久的将来可能会引用其附近的内存位置  看一个例子
1 2 3 4 5 6 7 8  int sumvec(int v[N]) { int i , sum = 0; for(i = 0; i &amp;lt; N; i ++) sum+=v[i]; return sum; }   这个函数中，sum就有很好的时间局部性，在多次循环中，会一直访问同一个内存位置，因为是标量所以没有空间局部性。 数组v被顺序读取，读取第i个位置，那么附近的位置也会在下次循环中读取，所以有很好的空间局部性，但每个变量只访问一次，所以时间局部性很差。 这个函数中要么有好的时间局部性，要么有好的空间局部性，所以sumvec函数有良好的局部性。
再看一个例子：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  int sumarray1(int a[M][N]) { int i ,j , sum = 0; for(i = 0;i &amp;lt; M ;i ++) for(j = 0; j &amp;lt; N ;j ++) sum+=a[i][j]; return sum; } int sumarray2(int a[M][N]) { int i ,j , sum = 0; for(i = 0;i &amp;lt; N;i ++) for(j = 0; j &amp;lt; M ;j ++) sum+=a[i][j]; return sum; }   两个程序做的事情一模一样，效率看起来也是一样的。但根据局部性原理： sumarray1有空间局部性，sumarry2则没有。 这个二维数组存储在内存的顺序是一行行的存储，也就是按照行来读就会按序读取，按列读取就会跳着读。 空间局部性的临近读取，导致最终sumarry1更高效。</description>
    </item>
    
    <item>
      <title>Go Channel</title>
      <link>https://example.com/post/2019/20190917-go-channel/</link>
      <pubDate>Tue, 17 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/post/2019/20190917-go-channel/</guid>
      <description>如何使用  channel在&amp;lt;-左边 表示向channel发送数据 channel在&amp;lt;-右边 表示从channel接收数据 close(channelName) 关闭一个channel  1 2 3 4 5 6 7 8  channel := make(chan string, 2) //发送数据: 写 channel &amp;lt;- &amp;#34;struct&amp;#34; //接收数据: 读 data := &amp;lt;-channel fmt.Println(data) close(channel)   Channel的关闭  关闭一个未初始化(nil) 的 channel 会产生 panic 重复关闭同一个 channel 会产生 panic 向一个已关闭的 channel 中发送消息会产生 panic 从一个已关闭的 channel 中读取消息永远不会阻塞，并且会返回一个为 false 状态，可以用它来判断 channel 是否关闭,close操作是对写入的关闭,但仍然可以读取,若消息均已读出，则会读到类型的初始值  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  func SendMessage(channel chan string) { go func(channel chan string) { channel &amp;lt;- &amp;#34;hello&amp;#34; close(channel) fmt.</description>
    </item>
    
    <item>
      <title>Go Groutine</title>
      <link>https://example.com/post/2019/20190917-go-groutine/</link>
      <pubDate>Tue, 17 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/post/2019/20190917-go-groutine/</guid>
      <description>并发与并行  并行(parallel): 指在同一时刻,有多条指令在多个处理器上同时执行(靠机器) 并发(concurrency): 指在同一时刻只能有一条指令执行,但多个进程指令被快速的轮换执行,宏观看起来是并行的,微观是cpu在不断的快速切换.(操作系统)  线程安全问题  协作式调度: 当线程终止或阻塞是发生调度 =&amp;gt; &amp;ldquo;主动让出&amp;rdquo; 抢占式调度: 允许逻辑上将可继续运行的线程在运行过程中暂停的调度方式 =&amp;gt; &amp;ldquo;被迫让出&amp;rdquo; 脏数据原因: 抢占式调度被迫让出cpu控制权,一个行为可能有多个指令组合而成 多指令在执行过程中被中断,导致未执行完整出现脏数据. 举例:  i= 0, 线程1 执行 i++,线程 2 也执行 i++, 想要的结果是2 当程序 1 将 i 值读取出来并运算后改为写入的时候,系统抢占式把控制权给个程序 2 程序 2 完整的执行完了 i++,随后系统将控制权交回给程序 1,此时的程序 1 并不知道自己被打断了,也不知道 i 已经被修改,还把之前计算好的值写入,最后把之前的2给覆盖了结果变成了1. 被打断是因为抢占式使用时间到了后被迫交还cpu 值篡改是因为读取i和写入i是两个指令不是一个原子操作    Coroutine(协程)特点 一种用户态的轻量级线程
 轻量级线程(由于线程创建时需要向操作系统申请资源,并且在销毁时将资源归还,因此它的创建和销毁的开销比较大,内存消耗更低,一般是2kb vs 1mb) 是语言层面的任务,非系统级别的(由语言层面虚拟机或者go runtime等 进行创建),切换更高效 多个协程可能在一个或多个线程上运行.依靠调度器分配 协作式: 非抢占式(协作)在关键时刻(阻塞,任务完成等)将cpu让给其他线程 同一线程上的多个协程的切换是无线程安全问题的  Goroutine  概念: goroutine是go语言中的协程 如何使用: go test() 在函数前加go关键字 就可以以新协程来启动test()函数 为什么说协程无线程安全问题: 协程是协作式本身无线程安全问题,但go runtime的scheduler会将多个goroutine分配到不同线程,才会出问题  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  var s int func test() { for i := 0; i &amp;lt; 10000; i++ { s++ } } func main() { runtime.</description>
    </item>
    
    <item>
      <title>读CSAPP(2) - 程序性能优化</title>
      <link>https://example.com/post/2019/20190909-csapp2/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/post/2019/20190909-csapp2/</guid>
      <description>高效的程序需要做到  合适的数据结构与算法 编写出编译器能够有效优化以转换成高效可执行代码的源码。 将运算量特别大的计算，可以分成多部分，这些部分可以在多核多处理器的某种组合上并行处理  本篇主要以第二点进行讨论，编译器在优化的时候只会做最坏打算，做各种假设。为了保证程序的准确性，舍弃性能优化。
编译器的优化限制 内存别名的使用 1 2 3 4 5 6 7 8 9 10  void twiddle1(long *xp, long *yp) { *xp += *yp; *xp += *yp; } void twiddle2(long *xp, long *yp) { *xp += 2* *yp; }   上面两个程序twiddle2（读xp，读yp，写xp）优于twiddl1（读2次xp，读2次yp，写2次xp）。 看起来编译器也许会将twiddle1优化成twiddle2的形式。但假设xp和yp是引用的同一个内存地址：&amp;amp;xp = &amp;amp;yp
1 2 3 4 5 6 7 8  void twiddle1(long *xp, long *yp){ *xp += *xp; *xp += *xp; } void twiddle2(long *xp, long *yp){ *xp += 2* *xp; }   代码则可以写成上面这样，这时候两个函数的意义就不同了，twiddle1将xp增加了4倍，twiddle2将xp增加了3倍。 两个指针指向同一个内存地址，称之为：内存别名使用，编译器必须假设不同指针可能指向相同地址，限制了优化策略</description>
    </item>
    
    <item>
      <title>Go 竞态问题</title>
      <link>https://example.com/post/2019/20190903-go-race-condition/</link>
      <pubDate>Tue, 03 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/post/2019/20190903-go-race-condition/</guid>
      <description>定义  单处理器中低优先级的进程被高优先级的进程抢占，同时他们访问同一块共享资源 多处理器中，CPU1的进程、CPU2的进程同时访问同一块共享资源  如何避免竞态条件  变量只读  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  //下面两种获取map信息的方式 //懒汉获取方式,有则获取无则加载: 会有读写错乱情况 func loadmap(name string) int { return 2 } func getmap2(name string) int { v, ok := maps[name] if !ok { v = loadmap(name) maps[name] = v } return v } //预先加载好, 使getmap只读, 就不会存在竞态问题 var maps = map[string]int{ &amp;#34;a&amp;#34;: 1, &amp;#34;b&amp;#34;: 2, &amp;#34;c&amp;#34;: 3, } func getmap(name string) int { return maps[name] }    私有化变量  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  //两个goroutine同时访问了变量a 引发竞态问题,导致结果不准确 var a = 0 var wg sync.</description>
    </item>
    
    <item>
      <title>读CSAPP(1) - 信息的表示和处理</title>
      <link>https://example.com/post/2019/20190827-csapp1/</link>
      <pubDate>Tue, 27 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/post/2019/20190827-csapp1/</guid>
      <description>计算机存的什么 计算机存储的是二进制，每一位存储的是0或1。大多数计算机使用1字节（也就是8位），作为最小可寻址的内存单位。 每个字节都有一个唯一的数字来标识，也就是地址（address）。每个计算机都有一个字长（word size），也就是常说的64位操作系统，32位操作系统。字长决定了虚拟地址空间的大小， 比如32位有4GB的内存空间，64位则是16EB（1TB = 1024GB，1 EB = 1,024 PB = 1,048,576 TB）。
整数 原码，反码，补码 计算机存储的是二进制，现实中数字有正负之分，二进制如果想表示正负数怎么办呢？ 为了解决正负数问题于是有了 原码 ，原码的表示方式是：第一位不再表示有效位，而是符号位，0代表正数，1代表负数
[1001] 这个8位二进制，本该表示 十进制的9，现在他表示为 -1，第一位（1）是符号位，后面的才是真正的值。
   正数 二进制 负数 二进制     +0 0000 -0 1000   +1 0001 -1 1001   +2 0010 -2 1010   +3 0011 -3 1011   +4 0100 -4 1100   +5 0101 -5 1101   +6 0110 -6 1110   +7 0111 -7 1111    现在计算机可以存储负数了，我们进行运算操作：</description>
    </item>
    
    <item>
      <title>暗时间</title>
      <link>https://example.com/post/read/20190821-%E6%9A%97%E6%97%B6%E9%97%B4/</link>
      <pubDate>Thu, 22 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://example.com/post/read/20190821-%E6%9A%97%E6%97%B6%E9%97%B4/</guid>
      <description>学习方面 最近看《暗时间》这本书，感觉很不错。
投入的时间≠实际时间，要用高效的方法学习，充分利用暗时间，学习过程要不断思考推断，而不是一味的死记硬背。
只有当进入沉浸状态学习效率才会提高，并且不被其他因素中断。 最后将学到的知识进行归纳，或者讲给别人听，加深巩固知识。 学习过程或者做一件事情的过程，如果能记录进度，知道自己还差多少完成，心里就会有所期待。
学以致用才是最终目的
实际时间 投入的时间*效率 才是真实的学习时间，不加以思索的学习，容易遗忘，效果低。
暗时间 吃饭，睡觉，公交等 这些碎片时间，进行思考刚学的知识。
沉浸状态 当所有心思都专注在这一件事上，这时候的效率是最高的。
中断 当专注某一件事的时候，突然被外界干扰，或者思绪突然想到了其他事情上。 如同计算机线程之间的切换，多个事情同时处理需要上下文的切换，会造成性能损耗。 专注突然被打断，再次重新专注需要时间
归纳知识 记笔记，或者写博客，按照自己思路将知识描述总结到文本中，加深印象。 建立索引，经常回顾，忘记时也能快速查到。
讲给别人听 这里的讲给别人，也可以是设想讲给别人听， 费曼学习法，大致意思就是将学到的知识，总结成按自己的理解思路进行描述出来，讲述给别人。 这样会更清楚的意识到自己理解了多少，哪里讲述的不清，说明哪里理解的不到位然后重新总结， 反复归纳总结，讲述，直到清晰表达出要点。
进度 当下载一个软件，能知道下载的进度，这样就能等下去，知道还有多久完成。 学习也一样，如果一直学，没有止境会给人心里感觉很徒劳。 可以将学习某一个知识，进行分段，比如将知识点分成几块，每天完成多少，大约1个月就能完成全部。 明确的目标事半功倍
 痛苦的秘密在于有闲工夫担心自己是否幸福。 &amp;ndash; 萧伯纳
 </description>
    </item>
    
  </channel>
</rss>
