---
title: "CSAPP(1) - 信息的表示和处理"
date: 2019-08-27T15:50:19+08:00
categories: [coder]
tags: [计算机]
series: [CSAPP]
# draft: true
---

### 计算机存的什么
&emsp;&emsp;计算机存储的是二进制，每一位存储的是0或1。大多数计算机使用1字节（也就是8位），作为最小可寻址的内存单位。
每个字节都有一个唯一的数字来标识，也就是地址（address）。每个计算机都有一个字长（word size），也就是常说的64位操作系统，32位操作系统。字长决定了虚拟地址空间的大小，
比如32位有4GB的内存空间，64位则是16EB（1TB = 1024GB，1 EB = 1,024 PB = 1,048,576 TB）。


### 原码，反码，补码
计算机存储的是二进制，现实中数字有正负之分，二进制如果想表示正负数怎么办呢？
为了解决**正负数问题**于是有了 **原码** ，原码的表示方式是：**第一位不再表示有效位，而是符号位，0代表正数，1代表负数**

[1001] 这个8位二进制，本该表示 十进制的9，现在他表示为 -1，第一位（1）是符号位，后面的才是真正的值。

| 正数 | 二进制 | 负数 | 二进制 |
| ---- | ------ | ---- | ------ |
| +0   | 0000   | -0   | 1000   |
| +1   | 0001   | -1   | 1001   |
| +2   | 0010   | -2   | 1010   |
| +3   | 0011   | -3   | 1011   |
| +4   | 0100   | -4   | 1100   |
| +5   | 0101   | -5   | 1101   |
| +6   | 0110   | -6   | 1110   |
| +7   | 0111   | -7   | 1111   |

现在计算机可以存储负数了，我们进行运算操作：

- 十进制：1+1 = 2 ； 二进制则是：0001+0001 = 0010
- 十进制：-1 + （-1） = -2 ； 二进制则是： 1001 + 1001 = 10010 第一位符号位仍然是1 仍然表示 - ，结果是-2 
- 十进制：1 + （-1） = 0；二进制则是：0001+1001 = 1010 结果是-2

从上面计算看出，当出现正负数相加的时候，结果会出现问题。 虽然原码表示了正负数，运算却有问题。
为了解决**正负数相加问题**于是有了**反码**，反码的表示方式是：**正数的反码是其本身，负数的反码是在其原码的基础上，符号位不变，其余各位取反**

| 正数 | 二进制 | 负数 | 二进制 |
| ---- | ------ | ---- | ------ |
| +0   | 0000   | -0   | 1111   |
| +1   | 0001   | -1   | 1110   |
| +2   | 0010   | -2   | 1101   |
| +3   | 0011   | -3   | 1100   |
| +4   | 0100   | -4   | 1011   |
| +5   | 0101   | -5   | 1010   |
| +6   | 0110   | -6   | 1001   |
| +7   | 0111   | -7   | 1000   |

现在我们看看正负数相加：

- 十进制：1 + （-1） = 0；二进制则是：0001+1110 = 1111 ，正好对应反码表里的 -0

这样就解决了正负数相加的问题，但现在还有一个问题： 0 有两种表示方式：0000和1111，现实中0是不分正负的，计算机也需要解决，否则判断是否为0还需要判断两次（+0和-0）。为了解决**0有两种表示类型** 于是有了 **补码**，补码的表示方式是：**正数的补码就是其本身，
负数的补码是在其原码的基础上，符号位不变，其余各位取反， 最后+1（负数反码+1）**

| 正数 | 二进制 | 负数 | 二进制 |
| ---- | ------ | ---- | ------ |
| +0   | 0000   | -0   | 0000   |
| +1   | 0001   | -1   | 1111   |
| +2   | 0010   | -2   | 1110   |
| +3   | 0011   | -3   | 1101   |
| +4   | 0100   | -4   | 1100   |
| +5   | 0101   | -5   | 1011   |
| +6   | 0110   | -6   | 1010   |
| +7   | 0111   | -7   | 1001   |
| --   | --     | -8   | 1000   |

- 原本1111表示-0，+1后： 1111+0001 = 10000，补位后溢出不计入，所以最终结果是0000
- 1000没有人用，于是就给了-8

现在正负0的二进制形式都为0000，并且还多出了一个表示数字-8
再来计算一下正负数相加：

- 十进制：1 + （-1） = 0；二进制则是：0001+1111 = 10000 ，溢出不计入，最终结果0000

### 运算溢出
如果存储大小为4位，取值范围就是[1000, 0111] -8 ~ 7。

正溢出：

- 十进制：5+5 = 10， 二进制0101+0101 = 1010（十进制结果-6），因为溢出导致将原来符号位的0改成了1，结果变成了负数。

负溢出：

- 十进制-5 + （-5）=-10，二进制1011+1011 = 0110（十进制结果6），溢出位不计入，最终因为溢出导致将原来符号位的1改成了0，结果变成了正数


### 有符号与无符号的转换
如果去掉符号位，就只能表示正数，因此多了一个表示位，增加了最大值。原码[1000，01111] 的范围是-8 ~ 7，去掉符号位的话就是[0000，1111] 0~15。在c语言中整型加上unsigned来表示无符号整数。

无符号转换成有符号公式：
$$
x=\begin{cases}
x,\quad x< 2^w/2 \\\\
x-2^w,\quad x\geq 2^w/2
\end{cases}
$$

| 十进制 | 无符号 | 有符号 | 最终十进制结果 |
| ------ | ------ | ------ | -------------- |
| 1      | 0001   | 0001   | 1              |
| 15     | 1111   | 1111   | -1             |

有符号转换成无符号公式：

$$
x=\begin{cases}
x+2^w,\quad x< 0 \\\\
x,\quad x\geq 0
\end{cases}
$$

| 十进制 | 有符号 | 无符号 | 最终十进制结果 |
| ------ | ------ | ------ | -------------- |
| 1      | 0001   | 0001   | 1              |
| -8     | 1000   | 1000   | 8              |
| -1     | 1001   | 1111   | 15             |


### 扩展与截断数字
#### 扩展（例如从 4位 到 8位）

- 无符号数：加 0


| 转换前的十进制 | 4位  | 8位        | 转换后的十进制 |
| -------------- | ---- | ---------- | -------------- |
| 1              | 0001 | 0000，0001 | 1              |
| 15             | 1111 | 0000，1111 | 15             |

- 有符号数：加符号位

| 转换前的十进制 | 4位  | 8位        | 转换后的十进制 |
| -------------- | ---- | ---------- | -------------- |
| -1             | 1001 | 1111，0001 | -1             |
| -8             | 1000 | 1111，1000 | -8             |


#### 截取：
如果将w位转为k位，其中w>k，则取后k位，移除 高位 w ~ k 的位。例如 8位 到 4位：则移除前4位，保留后4位。

- 无符号数：直接保留后四位

| 转换前的十进制 | 8位        | 4位  | 转换后的十进制 |
| -------------- | ---------- | ---- | -------------- |
| 17             | 0001，0001 | 0001 | 1              |
| 255            | 1111，1111 | 1111 | 15             |

- 有符号数：保留后四位，第一位表示符号位（结果是补码）

| 转换前的十进制 | 8位        | 4位  | 转换后的十进制 |
| -------------- | ---------- | ---- | -------------- |
| -9             | 1000，1001 | 1001 | -7             |
| -15            | 1000，1111 | 1111 | -1             |

### 浮点数的表示
原码，反码，补码，可以进行整数的运算和存储了，但小数如何表示。

### 大小端
数据在内存中的存储顺序方式有大小端之分。

举例：如果int类型的x 存储在0x100的位置，十六进制表示：0x01234567 ，根据大小端有两种不同存储方式：

- 大端： 按照最高有效位（这里是01）到最低有效位的顺序存储

| 0x100 | 0x200 | 0x300 | 0x400 |
| ----- | ----- | ----- | ----- |
| 01    | 23    | 45    | 67    |

- 小端：按照最低有效位（这里是67）到最高有效位的顺序存储

| 0x100 | 0x200 | 0x300 | 0x400 |
| ----- | ----- | ----- | ----- |
| 67    | 45    | 23    | 01    |

一般在应用层开发无需在意大小端，字节顺序不可见。只有在网络传输的时候，大端机器传输给小端机器，或者反过来时，才会有大小端转换问题。


### 参考
[张子秋的博客](https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html)

[插画-李俊达的回答 - 知乎](https://www.zhihu.com/question/20159860/answer/71256667)

[读薄csapp](https://wdxtub.com/csapp/thin-csapp-1/2016/04/16/)